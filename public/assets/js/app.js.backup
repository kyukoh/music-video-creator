/**
 * Music Video Creator - Main JavaScript Application
 */

// グローバル状態管理
const AppState = {
    currentProject: null,
    currentScene: null,
    isLoading: false,
    sidebarOpen: false
};

// API ユーティリティ
const API = {
    async get(url, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${url}?${queryString}` : url;
        
        const response = await fetch(fullUrl, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        return await response.json();
    },
    
    async post(url, data = {}) {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        return await response.json();
    },
    
    async put(url, data = {}) {
        const response = await fetch(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        });
        
        return await response.json();
    },
    
    async delete(url, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${url}?${queryString}` : url;
        
        const response = await fetch(fullUrl, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        return await response.json();
    }
};

// ユーティリティ関数
const Utils = {
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    formatFileSize(bytes) {
        const units = ['B', 'KB', 'MB', 'GB'];
        let unitIndex = 0;
        
        while (bytes >= 1024 && unitIndex < units.length - 1) {
            bytes /= 1024;
            unitIndex++;
        }
        
        return Math.round(bytes * 100) / 100 + ' ' + units[unitIndex];
    },
    
    formatDate(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('ja-JP') + ' ' + date.toLocaleTimeString('ja-JP');
    }
};

// ローディング管理
const Loading = {
    show(message = '読み込み中...') {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            const messageElement = overlay.querySelector('span');
            if (messageElement) {
                messageElement.textContent = message;
            }
            overlay.classList.remove('hidden');
        }
        AppState.isLoading = true;
    },
    
    hide() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            overlay.classList.add('hidden');
        }
        AppState.isLoading = false;
    }
};

// 通知管理
const Notification = {
    show(message, type = 'info', duration = 5000) {
        const container = document.getElementById('notification-container');
        if (!container) return;
        
        const notification = document.createElement('div');
        notification.className = `notification ${type} flex items-center justify-between`;
        notification.innerHTML = `
            <div class="flex items-center">
                <svg class="w-5 h-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    ${this.getIcon(type)}
                </svg>
                <span>${Utils.escapeHtml(message)}</span>
            </div>
            <button class="ml-4 text-white hover:text-gray-200 transition-colors">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        `;
        
        // 閉じるボタンのイベント
        notification.querySelector('button').addEventListener('click', () => {
            this.remove(notification);
        });
        
        container.appendChild(notification);
        
        // 自動削除
        if (duration > 0) {
            setTimeout(() => {
                this.remove(notification);
            }, duration);
        }
    },
    
    success(message, duration = 5000) {
        this.show(message, 'success', duration);
    },
    
    error(message, duration = 8000) {
        this.show(message, 'error', duration);
    },
    
    warning(message, duration = 6000) {
        this.show(message, 'warning', duration);
    },
    
    info(message, duration = 5000) {
        this.show(message, 'info', duration);
    },
    
    remove(notification) {
        notification.style.animation = 'slideOut 0.3s ease-in-out';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    },
    
    getIcon(type) {
        const icons = {
            success: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>',
            error: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>',
            warning: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>',
            info: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>'
        };
        return icons[type] || icons.info;
    }
};

// モーダル管理
const Modal = {
    /**
     * モーダルを作成して表示
     */
    create(title, content, maxWidth = 'max-w-2xl') {
        const modalContainer = document.getElementById('modal-container');
        if (!modalContainer) return null;
        
        const modalHTML = `
            <div class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
                <div class="modal-content bg-white rounded-lg shadow-xl ${maxWidth} w-full max-h-screen overflow-y-auto">
                    <div class="modal-header flex items-center justify-between p-6 border-b border-gray-200">
                        <h2 class="text-xl font-semibold text-gray-900">${title}</h2>
                        <button class="modal-close text-gray-400 hover:text-gray-600 transition-colors">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <div class="modal-body p-6">
                        ${content}
                    </div>
                </div>
            </div>
        `;
        
        modalContainer.innerHTML = modalHTML;
        modalContainer.classList.remove('hidden');
        
        // 閉じるボタンのイベント
        const closeBtn = modalContainer.querySelector('.modal-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.close());
        }
        
        // 背景クリックで閉じる
        const backdrop = modalContainer.querySelector('.modal-backdrop');
        if (backdrop) {
            backdrop.addEventListener('click', (e) => {
                if (e.target === backdrop) {
                    this.close();
                }
            });
        }
        
        // ESCキーで閉じる
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                this.close();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
        
        return modalContainer;
    },
    
    /**
     * モーダルを閉じる
     */
    close() {
        const modalContainer = document.getElementById('modal-container');
        if (modalContainer) {
            modalContainer.classList.add('hidden');
            modalContainer.innerHTML = '';
        }
    }
};

// モーダル関数のエイリアス（後方互換性のため）
function createModal(title, content, maxWidth) {
    return Modal.create(title, content, maxWidth);
}

function closeModal() {
    Modal.close();
}

// アプリケーション初期化
document.addEventListener('DOMContentLoaded', function() {
    console.log('Music Video Creator アプリケーションが開始されました');
    
    // UI初期化
    initializeUI();
    
    // プロジェクト一覧の読み込み
    loadProjectList();
});

/**
 * UI初期化
 */
function initializeUI() {
    // モバイルメニューの初期化
    initializeMobileMenu();
    
    // イベントリスナーの設定
    setupEventListeners();
    
    // レスポンシブ対応
    handleResize();
    window.addEventListener('resize', handleResize);
}

/**
 * モバイルメニューの初期化
 */
function initializeMobileMenu() {
    const mobileMenuBtn = document.getElementById('mobile-menu-btn');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const sidebar = document.getElementById('sidebar');
    
    if (mobileMenuBtn) {
        mobileMenuBtn.addEventListener('click', toggleSidebar);
    }
    
    if (sidebarToggle) {
        sidebarToggle.addEventListener('click', toggleSidebar);
    }
    
    // サイドバー外クリックで閉じる
    document.addEventListener('click', function(e) {
        if (AppState.sidebarOpen && 
            !sidebar.contains(e.target) && 
            !mobileMenuBtn.contains(e.target)) {
            closeSidebar();
        }
    });
}

/**
 * イベントリスナーの設定
 */
function setupEventListeners() {
    // 新規プロジェクトボタン
    const newProjectBtn = document.getElementById('new-project-btn');
    const getStartedBtn = document.getElementById('get-started-btn');
    
    if (newProjectBtn) {
        newProjectBtn.addEventListener('click', showCreateProjectModal);
    }
    
    if (getStartedBtn) {
        getStartedBtn.addEventListener('click', showCreateProjectModal);
    }
}

/**
 * レスポンシブ対応
 */
function handleResize() {
    const sidebar = document.getElementById('sidebar');
    const width = window.innerWidth;
    
    if (width >= 768) {
        // デスクトップ表示
        sidebar.classList.remove('open');
        AppState.sidebarOpen = false;
        removeSidebarOverlay();
    }
}

/**
 * サイドバーの開閉
 */
function toggleSidebar() {
    if (AppState.sidebarOpen) {
        closeSidebar();
    } else {
        openSidebar();
    }
}

function openSidebar() {
    const sidebar = document.getElementById('sidebar');
    sidebar.classList.add('open');
    AppState.sidebarOpen = true;
    
    // オーバーレイを追加（モバイル時）
    if (window.innerWidth < 768) {
        addSidebarOverlay();
    }
}

function closeSidebar() {
    const sidebar = document.getElementById('sidebar');
    sidebar.classList.remove('open');
    AppState.sidebarOpen = false;
    removeSidebarOverlay();
}

function addSidebarOverlay() {
    if (!document.getElementById('sidebar-overlay')) {
        const overlay = document.createElement('div');
        overlay.id = 'sidebar-overlay';
        overlay.className = 'fixed inset-0 bg-black bg-opacity-50 z-25';
        overlay.addEventListener('click', closeSidebar);
        document.body.appendChild(overlay);
    }
}

function removeSidebarOverlay() {
    const overlay = document.getElementById('sidebar-overlay');
    if (overlay) {
        overlay.remove();
    }
}

/**
 * プロジェクト一覧を読み込む
 */
async function loadProjectList() {
    try {
        Loading.show();
        const response = await API.get('api/projects.php');
        
        if (response.success) {
            renderProjectList(response.data || []);
            Notification.success('プロジェクト一覧を読み込みました');
        } else {
            throw new Error(response.error?.message || 'プロジェクト一覧の読み込みに失敗しました');
        }
    } catch (error) {
        console.error('プロジェクト一覧読み込みエラー:', error);
        Notification.error('プロジェクト一覧の読み込みに失敗しました');
        renderProjectList([]);
    } finally {
        Loading.hide();
    }
}

/**
 * プロジェクト一覧の描画
 */
function renderProjectList(projects) {
    const projectList = document.getElementById('project-list');
    
    if (!projects || projects.length === 0) {
        projectList.innerHTML = `
            <div class="text-center text-gray-400 py-8">
                <svg class="w-12 h-12 mx-auto mb-3 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                </svg>
                <p class="text-sm">プロジェクトがありません</p>
            </div>
        `;
        return;
    }
    
    const projectsHTML = projects.map(project => `
        <div class="project-item" data-project-id="${project.id}">
            <div class="flex items-center justify-between">
                <div class="flex-1 min-w-0">
                    <h3 class="text-sm font-medium text-gray-900 truncate">${Utils.escapeHtml(project.name)}</h3>
                    ${project.notes ? `<p class="text-xs text-gray-500 truncate mt-1">${Utils.escapeHtml(project.notes)}</p>` : ''}
                </div>
                <div class="flex items-center space-x-1 ml-2">
                    <button class="edit-project-btn p-1 text-gray-400 hover:text-gray-600 transition-colors" data-project-id="${project.id}" title="編集">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                        </svg>
                    </button>
                    <button class="delete-project-btn p-1 text-gray-400 hover:text-red-600 transition-colors" data-project-id="${project.id}" title="削除">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
    `).join('');
    
    projectList.innerHTML = projectsHTML;
    
    // イベントリスナーを追加
    projectList.querySelectorAll('.project-item').forEach(item => {
        item.addEventListener('click', function(e) {
            if (!e.target.closest('button')) {
                const projectId = this.dataset.projectId;
                selectProject(projectId);
            }
        });
    });
    
    projectList.querySelectorAll('.edit-project-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const projectId = this.dataset.projectId;
            showEditProjectModal(projectId);
        });
    });
    
    projectList.querySelectorAll('.delete-project-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const projectId = this.dataset.projectId;
            showDeleteProjectConfirm(projectId);
        });
    });
}

/**
 * プロジェクト選択
 */
async function selectProject(projectId) {
    try {
        Loading.show('プロジェクトを読み込み中...');
        
        // プロジェクト情報を取得
        const projectResponse = await API.get('api/projects.php', { id: projectId });
        
        if (!projectResponse.success) {
            throw new Error(projectResponse.error?.message || 'プロジェクトの読み込みに失敗しました');
        }
        
        // 現在のプロジェクトを設定
        AppState.currentProject = projectResponse.data;
        
        // プロジェクト一覧でアクティブ状態を更新
        updateProjectListSelection(projectId);
        
        // シーン一覧画面に遷移
        await loadSceneListView(projectId);
        
        // ページタイトルを更新
        updatePageTitle(AppState.currentProject.name);
        
        // モバイルでサイドバーを閉じる
        if (window.innerWidth < 768) {
            closeSidebar();
        }
        
        Notification.success(`プロジェクト「${AppState.currentProject.name}」を選択しました`);
        
    } catch (error) {
        console.error('プロジェクト選択エラー:', error);
        Notification.error('プロジェクトの選択に失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * プロジェクト一覧の選択状態を更新
 */
function updateProjectListSelection(selectedProjectId) {
    const projectItems = document.querySelectorAll('.project-item');
    
    projectItems.forEach(item => {
        const projectId = item.dataset.projectId;
        if (projectId === selectedProjectId) {
            item.classList.add('selected');
        } else {
            item.classList.remove('selected');
        }
    });
}

/**
 * ページタイトルを更新
 */
function updatePageTitle(title) {
    const pageTitleElement = document.getElementById('page-title');
    if (pageTitleElement) {
        pageTitleElement.textContent = title;
    }
    
    // ブラウザのタイトルも更新
    document.title = `${title} - Music Video Creator`;
}

/**
 * シーン一覧画面を読み込み
 */
async function loadSceneListView(projectId) {
    try {
        // シーン一覧を取得
        const scenesResponse = await API.get('api/scenes.php', { project_id: projectId });
        
        if (!scenesResponse.success) {
            throw new Error(scenesResponse.error?.message || 'シーン一覧の読み込みに失敗しました');
        }
        
        // シーン一覧画面を描画
        renderSceneListView(scenesResponse.data || []);
        
    } catch (error) {
        console.error('シーン一覧読み込みエラー:', error);
        Notification.error('シーン一覧の読み込みに失敗しました');
        
        // エラー時は空のシーン一覧を表示
        renderSceneListView([]);
    }
}

/**
 * シーン一覧画面の描画
 */
function renderSceneListView(scenes) {
    const mainContent = document.getElementById('main-content');
    
    const sceneListHTML = `
        <div class="p-6">
            <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                <!-- ヘッダー -->
                <div class="px-6 py-4 border-b border-gray-200 bg-gradient-to-r from-gray-50 to-white">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900">シーン一覧</h3>
                            <p class="text-sm text-gray-500 mt-1">
                                プロジェクト: ${Utils.escapeHtml(AppState.currentProject?.name || '')} 
                                ${scenes.length > 0 ? `(${scenes.length}シーン)` : ''}
                            </p>
                        </div>
                        <div class="flex items-center space-x-3">
                            <button id="media-library-btn" class="inline-flex items-center px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                                </svg>
                                メディアライブラリ
                            </button>
                            <button id="upload-scenes-btn" class="inline-flex items-center px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                ファイルアップロード
                            </button>
                            <button id="add-scene-btn" class="inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                                シーン追加
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- シーン一覧テーブル -->
                ${scenes.length > 0 ? `
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-20">
                                    <div class="flex items-center">
                                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                        </svg>
                                        サムネイル
                                    </div>
                                </th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">
                                    <div class="flex items-center">
                                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                        </svg>
                                        開始時間
                                    </div>
                                </th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    <div class="flex items-center">
                                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"></path>
                                        </svg>
                                        歌詞
                                    </div>
                                </th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    <div class="flex items-center">
                                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4V2a1 1 0 011-1h8a1 1 0 011 1v2m0 0V1a1 1 0 011-1h2a1 1 0 011 1v3M7 4H5a1 1 0 00-1 1v16a1 1 0 001 1h14a1 1 0 001-1V5a1 1 0 00-1-1h-2M7 4h10M9 9h6m-6 4h6m-6 4h6"></path>
                                        </svg>
                                        シーン説明
                                    </div>
                                </th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                    <div class="flex items-center">
                                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                                        </svg>
                                        英語プロンプト
                                    </div>
                                </th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-20">
                                    操作
                                </th>
                            </tr>
                        </thead>
                        <tbody id="scene-list-body" class="bg-white divide-y divide-gray-200">
                            ${renderSceneRows(scenes)}
                        </tbody>
                    </table>
                </div>
                ` : `
                <div class="text-center py-16">
                    <div class="max-w-sm mx-auto">
                        <svg class="w-20 h-20 mx-auto mb-6 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                        <h4 class="text-xl font-semibold text-gray-900 mb-3">シーンがありません</h4>
                        <p class="text-gray-500 mb-8 leading-relaxed">
                            このプロジェクトにはまだシーンが登録されていません。<br>
                            新しいシーンを追加するか、ファイルからシーンを一括登録してください。
                        </p>
                        <div class="flex flex-col sm:flex-row justify-center gap-3">
                            <button class="inline-flex items-center px-6 py-3 text-sm font-medium text-white bg-primary-600 rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors" onclick="document.getElementById('add-scene-btn').click()">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                                シーン追加
                            </button>
                            <button class="inline-flex items-center px-6 py-3 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors" onclick="document.getElementById('upload-scenes-btn').click()">
                                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                </svg>
                                ファイルアップロード
                            </button>
                        </div>
                    </div>
                </div>
                `}
            </div>
        </div>
    `;
    
    mainContent.innerHTML = sceneListHTML;
    
    // イベントリスナーを設定
    setupSceneListEventListeners();
}

/**
 * シーン行の描画
 */
function renderSceneRows(scenes) {
    if (!scenes || scenes.length === 0) {
        return '';
    }
    
    return scenes.map((scene, index) => `
        <tr class="scene-row hover:bg-gray-50 transition-colors" data-scene-id="${scene.id}" data-order="${scene.order || index + 1}" draggable="true">
            <td class="px-6 py-4 whitespace-nowrap relative">
                <div class="flex items-center">
                    <div class="drag-handle mr-2 cursor-move text-gray-400 hover:text-gray-600" title="ドラッグして並び替え">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path>
                        </svg>
                    </div>
                    <div class="w-16 h-12 bg-gray-200 rounded-md flex items-center justify-center cursor-pointer hover:bg-gray-300 transition-colors shadow-sm" 
                         onclick="openSceneDetail('${scene.id}')" title="詳細編集画面を開く">
                        ${scene.image_file_id ? 
                            `<img src="data/projects/${AppState.currentProject.id}/media/images/${scene.image_file_id}" 
                                  class="w-full h-full object-cover rounded-md" alt="シーン${scene.order || index + 1}のサムネイル"
                                  onerror="this.parentElement.innerHTML='<svg class=\\"w-6 h-6 text-gray-400\\" fill=\\"none\\" stroke=\\"currentColor\\" viewBox=\\"0 0 24 24\\"><path stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\\"></path></svg>'">` :
                            `<svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>`
                        }
                    </div>
                </div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <input type="text" 
                       class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded transition-colors" 
                       data-field="start_time" 
                       data-scene-id="${scene.id}"
                       value="${Utils.escapeHtml(scene.start_time || '')}"
                       placeholder="0:00"
                       pattern="[0-9]+:[0-5][0-9]"
                       title="時間形式: M:SS または MM:SS">
            </td>
            <td class="px-6 py-4">
                <textarea class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded resize-none transition-colors" 
                          data-field="lyrics" 
                          data-scene-id="${scene.id}"
                          rows="2"
                          placeholder="歌詞を入力..."
                          title="このシーンの歌詞部分">${Utils.escapeHtml(scene.lyrics || '')}</textarea>
            </td>
            <td class="px-6 py-4">
                <textarea class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded resize-none transition-colors" 
                          data-field="description" 
                          data-scene-id="${scene.id}"
                          rows="2"
                          placeholder="シーン説明を入力..."
                          title="映像の内容やコンセプトの説明">${Utils.escapeHtml(scene.description || '')}</textarea>
            </td>
            <td class="px-6 py-4">
                <textarea class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded resize-none transition-colors" 
                          data-field="image_prompt" 
                          data-scene-id="${scene.id}"
                          rows="2"
                          placeholder="英語プロンプトを入力..."
                          title="AI画像生成用の英語プロンプト">${Utils.escapeHtml(scene.image_prompt || '')}</textarea>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <div class="flex items-center justify-end space-x-2">
                    <span class="text-xs text-gray-400 mr-2">#${scene.order || index + 1}</span>
                    <button class="delete-scene-btn p-1 text-red-600 hover:text-red-900 hover:bg-red-50 rounded transition-colors" 
                            data-scene-id="${scene.id}" 
                            title="シーンを削除">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                </div>
            </td>
        </tr>
    `).join('');
}

/**
 * シーン一覧のイベントリスナー設定
 */
function setupSceneListEventListeners() {
    // シーン追加ボタン
    const addSceneBtn = document.getElementById('add-scene-btn');
    if (addSceneBtn) {
        addSceneBtn.addEventListener('click', addNewScene);
    }
    
    // ファイルアップロードボタン
    const uploadScenesBtn = document.getElementById('upload-scenes-btn');
    if (uploadScenesBtn) {
        uploadScenesBtn.addEventListener('click', () => {
            // 後のタスクで実装予定
            Notification.info('ファイルアップロード機能は後のタスクで実装されます');
        });
    }
    
    // メディアライブラリボタン
    const mediaLibraryBtn = document.getElementById('media-library-btn');
    if (mediaLibraryBtn) {
        mediaLibraryBtn.addEventListener('click', () => {
            loadMediaLibraryView();
        });
    }
    
    // ドラッグ&ドロップ並び替え機能の設定
    setupDragAndDropEvents();
    
    // シーンフィールドのインライン編集
    const sceneFields = document.querySelectorAll('.scene-field');
    sceneFields.forEach(field => {
        // 元の値を保存
        field.dataset.originalValue = field.value;
        
        // フォーカス時の処理
        field.addEventListener('focus', function() {
            this.classList.add('editing');
            this.closest('tr').classList.add('editing-row');
            this.dataset.originalValue = this.value;
            
            // バリデーションエラーをクリア
            hideValidationError(this);
            hideSaveIndicator(this);
            
            // フォーカス時にテキストを選択（開始時間フィールドのみ）
            if (this.dataset.field === 'start_time' && this.value) {
                setTimeout(() => this.select(), 0);
            }
        });
        
        // フォーカス離脱時の処理
        field.addEventListener('blur', function() {
            this.classList.remove('editing');
            this.closest('tr').classList.remove('editing-row');
            
            // 値が変更されている場合のみ自動保存
            const currentValue = this.value.trim();
            const originalValue = this.dataset.originalValue.trim();
            
            if (currentValue !== originalValue) {
                // バリデーションチェック
                if (this.dataset.field === 'start_time' && !validateTimeFormat(this)) {
                    // バリデーションエラーの場合は保存しない
                    return;
                }
                
                autoSaveSceneField(this);
            } else {
                // 変更がない場合は状態をクリア
                this.classList.remove('modified', 'saving', 'saved', 'save-error');
                hideValidationError(this);
                hideSaveIndicator(this);
            }
        });
        
        // キーボードイベントの処理
        field.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                
                // バリデーションチェック
                if (this.dataset.field === 'start_time' && !validateTimeFormat(this)) {
                    return; // バリデーションエラーの場合は移動しない
                }
                
                // 現在の値を保存してから次のフィールドに移動
                const currentValue = this.value.trim();
                const originalValue = this.dataset.originalValue.trim();
                
                if (currentValue !== originalValue) {
                    autoSaveSceneField(this);
                }
                
                // 次のフィールドに移動
                moveToNextField(this);
                
            } else if (e.key === 'Escape') {
                // Escapeキーで変更をキャンセル
                this.value = this.dataset.originalValue;
                this.classList.remove('modified', 'invalid');
                hideValidationError(this);
                hideSaveIndicator(this);
                this.blur();
                
            } else if (e.key === 'Tab') {
                // Tabキーでの移動時も保存
                const currentValue = this.value.trim();
                const originalValue = this.dataset.originalValue.trim();
                
                if (currentValue !== originalValue) {
                    if (this.dataset.field === 'start_time' && !validateTimeFormat(this)) {
                        e.preventDefault();
                        return;
                    }
                    autoSaveSceneField(this);
                }
            }
        });
        
        // 入力時のリアルタイム処理
        field.addEventListener('input', function() {
            // リアルタイムバリデーション
            if (this.dataset.field === 'start_time') {
                validateTimeFormat(this);
            }
            
            // 変更状態の視覚的表示
            const currentValue = this.value.trim();
            const originalValue = this.dataset.originalValue.trim();
            
            if (currentValue !== originalValue) {
                this.classList.add('modified');
                this.classList.remove('saved', 'save-error');
                
                // デバウンス付き自動保存をスケジュール
                scheduleAutoSave(this);
            } else {
                this.classList.remove('modified', 'saved', 'save-error');
                hideValidationError(this);
                hideSaveIndicator(this);
                
                // 自動保存をキャンセル
                cancelAutoSave(this);
            }
        });
        
        // 時間フィールドの特別な処理
        if (field.dataset.field === 'start_time') {
            // 数字キーと特定の記号のみ許可
            field.addEventListener('keypress', function(e) {
                const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':'];
                const specialKeys = ['Backspace', 'Delete', 'Tab', 'Escape', 'Enter', 'ArrowLeft', 'ArrowRight'];
                
                if (!allowedKeys.includes(e.key) && !specialKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                }
            });
            
            // ペースト時の処理
            field.addEventListener('paste', function(e) {
                setTimeout(() => {
                    validateTimeFormat(this);
                }, 0);
            });
        }
    });
    
    // シーン削除ボタンのイベントリスナー
    const deleteSceneBtns = document.querySelectorAll('.delete-scene-btn');
    deleteSceneBtns.forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const sceneId = this.dataset.sceneId;
            showDeleteSceneConfirm(sceneId);
        });
    });
    
    // ドラッグ&ドロップの設定
    setupDragAndDropEvents();
}

/**
 * 次のフィールドに移動
 */
function moveToNextField(currentField) {
    const allFields = Array.from(document.querySelectorAll('.scene-field'));
    const currentIndex = allFields.indexOf(currentField);
    
    if (currentIndex >= 0 && currentIndex < allFields.length - 1) {
        const nextField = allFields[currentIndex + 1];
        nextField.focus();
        
        // テキストエリアの場合は最初にカーソルを移動
        if (nextField.tagName === 'TEXTAREA') {
            nextField.setSelectionRange(0, 0);
        } else {
            nextField.select();
        }
    }
}

/**
 * デバウンス付き自動保存のスケジュール
 */
const autoSaveTimers = new Map();

function scheduleAutoSave(fieldElement) {
    const fieldKey = `${fieldElement.dataset.sceneId}-${fieldElement.dataset.field}`;
    
    // 既存のタイマーをクリア
    if (autoSaveTimers.has(fieldKey)) {
        clearTimeout(autoSaveTimers.get(fieldKey));
    }
    
    // 新しいタイマーを設定（2秒後に自動保存）
    const timer = setTimeout(() => {
        // バリデーションチェック
        if (fieldElement.dataset.field === 'start_time' && !validateTimeFormat(fieldElement)) {
            return;
        }
        
        const currentValue = fieldElement.value.trim();
        const originalValue = fieldElement.dataset.originalValue.trim();
        
        if (currentValue !== originalValue) {
            autoSaveSceneField(fieldElement);
        }
        
        autoSaveTimers.delete(fieldKey);
    }, 2000);
    
    autoSaveTimers.set(fieldKey, timer);
}

/**
 * 自動保存のキャンセル
 */
function cancelAutoSave(fieldElement) {
    const fieldKey = `${fieldElement.dataset.sceneId}-${fieldElement.dataset.field}`;
    
    if (autoSaveTimers.has(fieldKey)) {
        clearTimeout(autoSaveTimers.get(fieldKey));
        autoSaveTimers.delete(fieldKey);
    }
}

/**
 * 次のフィールドに移動
 */
function moveToNextField(currentField) {
    const currentRow = currentField.closest('tr');
    const allFields = currentRow.querySelectorAll('.scene-field');
    const currentIndex = Array.from(allFields).indexOf(currentField);
    const nextField = allFields[currentIndex + 1];
    
    if (nextField) {
        // 同じ行の次のフィールドに移動
        nextField.focus();
    } else {
        // 最後のフィールドの場合、次の行の最初のフィールドに移動
        const nextRow = currentRow.nextElementSibling;
        if (nextRow && nextRow.classList.contains('scene-row')) {
            const firstField = nextRow.querySelector('.scene-field');
            if (firstField) {
                firstField.focus();
            }
        } else {
            // 最後の行の場合はフォーカスを外す
            currentField.blur();
        }
    }
}

/**
 * デバウンス付き自動保存をスケジュール
 */
function scheduleAutoSave(fieldElement) {
    const fieldKey = `${fieldElement.dataset.sceneId}-${fieldElement.dataset.field}`;
    
    // 既存のタイマーをクリア
    if (autoSaveTimers.has(fieldKey)) {
        clearTimeout(autoSaveTimers.get(fieldKey));
    }
    
    // 新しいタイマーを設定（2秒後に自動保存）
    const timer = setTimeout(() => {
        // フィールドがまだ存在し、フォーカスされていない場合のみ自動保存
        if (fieldElement.isConnected && document.activeElement !== fieldElement) {
            const currentValue = fieldElement.value.trim();
            const originalValue = fieldElement.dataset.originalValue.trim();
            
            if (currentValue !== originalValue) {
                // バリデーションチェック
                if (fieldElement.dataset.field === 'start_time' && !validateTimeFormat(fieldElement)) {
                    return;
                }
                
                autoSaveSceneField(fieldElement);
            }
        }
        
        autoSaveTimers.delete(fieldKey);
    }, 2000);
    
    autoSaveTimers.set(fieldKey, timer);
}

/**
 * 自動保存をキャンセル
 */
function cancelAutoSave(fieldElement) {
    const fieldKey = `${fieldElement.dataset.sceneId}-${fieldElement.dataset.field}`;
    
    if (autoSaveTimers.has(fieldKey)) {
        clearTimeout(autoSaveTimers.get(fieldKey));
        autoSaveTimers.delete(fieldKey);
    }
}

/**
 * すべての自動保存タイマーをクリア
 */
function clearAllAutoSaveTimers() {
    autoSaveTimers.forEach(timer => clearTimeout(timer));
    autoSaveTimers.clear();
}

/**
 * シーン一覧のイベントリスナーを設定
 */
function setupSceneListEventListeners() {
    // シーン削除ボタン
    const deleteSceneBtns = document.querySelectorAll('.delete-scene-btn');
    deleteSceneBtns.forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const sceneId = this.dataset.sceneId;
            showDeleteSceneConfirm(sceneId);
        });
    });
    
    // シーン行のホバー効果
    const sceneRows = document.querySelectorAll('.scene-row');
    sceneRows.forEach(row => {
        row.addEventListener('mouseenter', function() {
            this.classList.add('hover-highlight');
        });
        
        row.addEventListener('mouseleave', function() {
            this.classList.remove('hover-highlight');
        });
    });
    
    // ドラッグ&ドロップ機能の設定
    setupDragAndDrop();
}

/**
 * 時間フォーマットのバリデーション
 */
function validateTimeFormat(input) {
    const value = input.value.trim();
    
    // 空の場合は有効とする
    if (!value) {
        input.classList.remove('invalid');
        input.title = '時間形式: M:SS または MM:SS (例: 1:30, 12:45)';
        hideValidationError(input);
        return true;
    }
    
    // 時間フォーマットの正規表現: M:SS または MM:SS
    const timePattern = /^([0-9]+):([0-5][0-9])$/;
    const match = value.match(timePattern);
    
    if (!match) {
        input.classList.add('invalid');
        input.title = '正しい時間形式で入力してください (例: 1:30, 12:45)';
        showValidationError(input, '時間形式が正しくありません');
        return false;
    }
    
    const minutes = parseInt(match[1]);
    const seconds = parseInt(match[2]);
    
    // 分数の上限チェック（99分まで）
    if (minutes > 99) {
        input.classList.add('invalid');
        input.title = '分数は99分以下で入力してください';
        showValidationError(input, '分数は99分以下で入力してください');
        return false;
    }
    
    // 秒数は正規表現で0-59の範囲をチェック済み
    input.classList.remove('invalid');
    input.title = '時間形式: M:SS または MM:SS';
    hideValidationError(input);
    return true;
}

/**
 * バリデーションエラーの表示
 */
function showValidationError(input, message) {
    // 既存のエラーメッセージを削除
    hideValidationError(input);
    
    const errorElement = document.createElement('div');
    errorElement.className = 'validation-error absolute z-10 mt-1 px-2 py-1 text-xs text-red-600 bg-red-50 border border-red-200 rounded shadow-sm';
    errorElement.textContent = message;
    errorElement.id = `error-${input.dataset.sceneId}-${input.dataset.field}`;
    
    // 入力フィールドの親要素に相対位置を設定
    const container = input.closest('td');
    if (container) {
        container.style.position = 'relative';
        container.appendChild(errorElement);
    }
}

/**
 * バリデーションエラーの非表示
 */
function hideValidationError(input) {
    const errorId = `error-${input.dataset.sceneId}-${input.dataset.field}`;
    const existingError = document.getElementById(errorId);
    if (existingError) {
        existingError.remove();
    }
}

/**
 * ドラッグ&ドロップ機能の設定
 */
function setupDragAndDrop() {
    const sceneRows = document.querySelectorAll('.scene-row');
    
    sceneRows.forEach(row => {
        // ドラッグ開始
        row.addEventListener('dragstart', function(e) {
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
            e.dataTransfer.setData('text/plain', this.dataset.sceneId);
            
            // ドラッグ中は他の行のホバー効果を無効化
            document.querySelectorAll('.scene-row').forEach(r => {
                if (r !== this) {
                    r.classList.add('drag-mode');
                }
            });
        });
        
        // ドラッグ終了
        row.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            
            // すべての行からドロップ関連のクラスを削除
            document.querySelectorAll('.scene-row').forEach(r => {
                r.classList.remove('drag-over', 'drop-above', 'drop-below', 'drag-mode');
            });
        });
        
        // ドラッグオーバー
        row.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const draggingElement = document.querySelector('.scene-row.dragging');
            if (draggingElement && draggingElement !== this) {
                // ドロップ位置を決定
                const rect = this.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                
                // すべての行からドロップクラスを削除
                document.querySelectorAll('.scene-row').forEach(r => {
                    r.classList.remove('drop-above', 'drop-below');
                });
                
                if (e.clientY < midpoint) {
                    this.classList.add('drop-above');
                } else {
                    this.classList.add('drop-below');
                }
            }
        });
        
        // ドラッグリーブ
        row.addEventListener('dragleave', function(e) {
            // 要素の境界を完全に離れた場合のみクラスを削除
            const rect = this.getBoundingClientRect();
            if (e.clientX < rect.left || e.clientX > rect.right || 
                e.clientY < rect.top || e.clientY > rect.bottom) {
                this.classList.remove('drag-over', 'drop-above', 'drop-below');
            }
        });
        
        // ドロップ
        row.addEventListener('drop', function(e) {
            e.preventDefault();
            
            const draggedSceneId = e.dataTransfer.getData('text/plain');
            const draggedElement = document.querySelector(`[data-scene-id="${draggedSceneId}"]`);
            
            if (draggedElement && draggedElement !== this) {
                // ドロップ位置を決定
                const rect = this.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                const dropAbove = e.clientY < midpoint;
                
                // 新しい順序を計算して並び替えを実行
                reorderScenes(draggedSceneId, this.dataset.sceneId, dropAbove);
            }
            
            // クリーンアップ
            document.querySelectorAll('.scene-row').forEach(r => {
                r.classList.remove('dragging', 'drag-over', 'drop-above', 'drop-below', 'drag-mode');
            });
        });
    });
}

/**
 * シーンの並び替えを実行
 */
async function reorderScenes(draggedSceneId, targetSceneId, dropAbove) {
    try {
        // 現在のシーン順序を取得
        const sceneRows = Array.from(document.querySelectorAll('.scene-row'));
        const sceneIds = sceneRows.map(row => row.dataset.sceneId);
        
        // ドラッグされたシーンのインデックスを取得
        const draggedIndex = sceneIds.indexOf(draggedSceneId);
        const targetIndex = sceneIds.indexOf(targetSceneId);
        
        if (draggedIndex === -1 || targetIndex === -1) {
            throw new Error('Invalid scene IDs');
        }
        
        // 新しい順序を計算
        const newSceneIds = [...sceneIds];
        
        // ドラッグされたアイテムを削除
        newSceneIds.splice(draggedIndex, 1);
        
        // 新しい位置に挿入
        let insertIndex = targetIndex;
        if (draggedIndex < targetIndex) {
            insertIndex = targetIndex - 1;
        }
        
        if (!dropAbove) {
            insertIndex += 1;
        }
        
        newSceneIds.splice(insertIndex, 0, draggedSceneId);
        
        // 順序が変わっていない場合は何もしない
        if (JSON.stringify(sceneIds) === JSON.stringify(newSceneIds)) {
            return;
        }
        
        // APIに送信
        Loading.show('シーンを並び替え中...');
        
        const response = await API.post('api/scenes.php', {
            action: 'reorder',
            project_id: AppState.currentProject.id,
            scene_ids: newSceneIds
        });
        
        if (response.success) {
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            Notification.success('シーンの順序を更新しました');
        } else {
            throw new Error(response.error?.message || 'シーンの並び替えに失敗しました');
        }
        
    } catch (error) {
        console.error('シーン並び替えエラー:', error);
        Notification.error('シーンの並び替えに失敗しました');
        
        // エラー時はシーン一覧を再読み込みして元の状態に戻す
        await loadSceneListView(AppState.currentProject.id);
    } finally {
        Loading.hide();
    }
}

/**
 * シーンフィールドの自動保存
 */
async function autoSaveSceneField(fieldElement) {
    const sceneId = fieldElement.dataset.sceneId;
    const fieldName = fieldElement.dataset.field;
    const newValue = fieldElement.value.trim();
    
    if (!sceneId || !fieldName) {
        console.error('シーン保存エラー: シーンIDまたはフィールド名が不正です');
        return false;
    }
    
    // バリデーション
    if (fieldName === 'start_time' && !validateTimeFormat(fieldElement)) {
        return false;
    }
    
    // 既に保存中の場合はスキップ
    if (fieldElement.classList.contains('saving')) {
        return false;
    }
    
    try {
        // 保存中の視覚的フィードバック
        fieldElement.classList.remove('saved', 'save-error', 'modified');
        fieldElement.classList.add('saving');
        showSavingIndicator(fieldElement);
        
        // APIに保存リクエストを送信
        const updateData = {
            project_id: AppState.currentProject.id,
            [fieldName]: newValue
        };
        
        const response = await API.put(`api/scenes.php?id=${sceneId}`, updateData);
        
        if (response.success) {
            // 保存成功
            fieldElement.classList.remove('saving');
            fieldElement.classList.add('saved');
            fieldElement.dataset.originalValue = newValue;
            
            showSaveSuccessIndicator(fieldElement);
            
            // 成功状態を一定時間後にクリア
            setTimeout(() => {
                if (fieldElement.isConnected) {
                    fieldElement.classList.remove('saved');
                    hideSaveIndicator(fieldElement);
                }
            }, 2000);
            
            return true;
            
        } else {
            throw new Error(response.error?.message || 'シーンの保存に失敗しました');
        }
        
    } catch (error) {
        console.error('シーン保存エラー:', error);
        
        // 保存失敗の視覚的フィードバック
        fieldElement.classList.remove('saving');
        fieldElement.classList.add('save-error');
        
        showSaveErrorIndicator(fieldElement);
        
        // エラー通知（デバウンス付き）
        showDebouncedErrorNotification(`保存に失敗しました: ${error.message}`);
        
        // エラー状態を一定時間後にクリア
        setTimeout(() => {
            if (fieldElement.isConnected) {
                fieldElement.classList.remove('save-error');
                hideSaveIndicator(fieldElement);
            }
        }, 5000);
        
        return false;
    }
}

/**
 * デバウンス付きエラー通知
 */
let errorNotificationTimer = null;
function showDebouncedErrorNotification(message) {
    if (errorNotificationTimer) {
        clearTimeout(errorNotificationTimer);
    }
    
    errorNotificationTimer = setTimeout(() => {
        Notification.error(message);
        errorNotificationTimer = null;
    }, 500);
}

/**
 * 未保存の変更があるかチェック
 */
function hasUnsavedChanges() {
    const modifiedFields = document.querySelectorAll('.scene-field.modified, .scene-field.saving');
    return modifiedFields.length > 0;
}

/**
 * すべての未保存変更を保存
 */
async function saveAllPendingChanges() {
    const modifiedFields = document.querySelectorAll('.scene-field.modified');
    const savePromises = [];
    
    modifiedFields.forEach(field => {
        // バリデーションチェック
        if (field.dataset.field === 'start_time' && !validateTimeFormat(field)) {
            return;
        }
        
        const currentValue = field.value.trim();
        const originalValue = field.dataset.originalValue.trim();
        
        if (currentValue !== originalValue) {
            savePromises.push(autoSaveSceneField(field));
        }
    });
    
    if (savePromises.length > 0) {
        try {
            await Promise.all(savePromises);
            console.log('すべての変更が保存されました');
        } catch (error) {
            console.error('一部の変更の保存に失敗しました:', error);
        }
    }
}

/**
 * 保存中インジケーターの表示
 */
function showSavingIndicator(fieldElement) {
    hideSaveIndicator(fieldElement); // 既存のインジケーターを削除
    
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator saving-indicator';
    indicator.innerHTML = `
        <svg class="w-4 h-4 text-blue-600 loading" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
    `;
    indicator.title = '保存中...';
    
    const container = fieldElement.closest('td');
    if (container) {
        container.style.position = 'relative';
        container.appendChild(indicator);
    }
}

/**
 * 保存成功インジケーターの表示
 */
function showSaveSuccessIndicator(fieldElement) {
    hideSaveIndicator(fieldElement); // 既存のインジケーターを削除
    
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator success-indicator';
    indicator.innerHTML = `
        <svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
        </svg>
    `;
    indicator.title = '保存完了';
    
    const container = fieldElement.closest('td');
    if (container) {
        container.style.position = 'relative';
        container.appendChild(indicator);
    }
}

/**
 * 保存エラーインジケーターの表示
 */
function showSaveErrorIndicator(fieldElement) {
    hideSaveIndicator(fieldElement); // 既存のインジケーターを削除
    
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator error-indicator';
    indicator.innerHTML = `
        <svg class="w-4 h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
    `;
    indicator.title = '保存失敗';
    
    const container = fieldElement.closest('td');
    if (container) {
        container.style.position = 'relative';
        container.appendChild(indicator);
    }
}

/**
 * 保存インジケーターの非表示
 */
function hideSaveIndicator(fieldElement) {
    const container = fieldElement.closest('td');
    if (container) {
        const existingIndicator = container.querySelector('.save-indicator');
        if (existingIndicator) {
            existingIndicator.remove();
        }
    }
}

/**
 * 保存中インジケーターを表示
 */
function showSavingIndicator(fieldElement) {
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator saving-indicator';
    indicator.innerHTML = `
        <svg class="w-4 h-4 animate-spin text-blue-500" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
    `;
    
    const cell = fieldElement.closest('td');
    cell.style.position = 'relative';
    cell.appendChild(indicator);
}

/**
 * 保存成功インジケーターを表示
 */
function showSaveSuccessIndicator(fieldElement) {
    const existingIndicator = fieldElement.closest('td').querySelector('.save-indicator');
    if (existingIndicator) {
        existingIndicator.className = 'save-indicator success-indicator';
        existingIndicator.innerHTML = `
            <svg class="w-4 h-4 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
        `;
        
        setTimeout(() => {
            existingIndicator.remove();
        }, 2000);
    }
}

/**
 * 保存エラーインジケーターを表示
 */
function showSaveErrorIndicator(fieldElement) {
    const existingIndicator = fieldElement.closest('td').querySelector('.save-indicator');
    if (existingIndicator) {
        existingIndicator.className = 'save-indicator error-indicator';
        existingIndicator.innerHTML = `
            <svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
        `;
        
        setTimeout(() => {
            existingIndicator.remove();
        }, 3000);
    }
}

/**
 * 新しいシーンを追加
 */
async function addNewScene() {
    if (!AppState.currentProject) {
        Notification.error('プロジェクトが選択されていません');
        return;
    }
    
    try {
        Loading.show('新しいシーンを追加中...');
        
        // 新しいシーンのデータ
        const newSceneData = {
            project_id: AppState.currentProject.id,
            start_time: '0:00',
            lyrics: '',
            description: '',
            image_prompt: '',
            video_prompt: ''
        };
        
        // APIでシーンを作成
        const response = await API.post('api/scenes.php', newSceneData);
        
        if (response.success) {
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            
            // 新しく追加されたシーンの最初のフィールドにフォーカス
            setTimeout(() => {
                const sceneRows = document.querySelectorAll('.scene-row');
                if (sceneRows.length > 0) {
                    const lastRow = sceneRows[sceneRows.length - 1];
                    const firstField = lastRow.querySelector('.scene-field');
                    if (firstField) {
                        firstField.focus();
                        firstField.select();
                    }
                }
            }, 100);
            
            Notification.success('新しいシーンを追加しました');
            
        } else {
            throw new Error(response.error?.message || 'シーンの追加に失敗しました');
        }
        
    } catch (error) {
        console.error('シーン追加エラー:', error);
        Notification.error(`シーンの追加に失敗しました: ${error.message}`);
    } finally {
        Loading.hide();
    }
}

/**
 * シーン削除確認ダイアログを表示
 */
function showDeleteSceneConfirm(sceneId) {
    if (!sceneId) {
        Notification.error('シーンIDが不正です');
        return;
    }
    
    // シーン情報を取得
    const sceneRow = document.querySelector(`[data-scene-id="${sceneId}"]`);
    const sceneOrder = sceneRow ? sceneRow.dataset.order : '不明';
    const sceneLyrics = sceneRow ? sceneRow.querySelector('[data-field="lyrics"]').value : '';
    const displayText = sceneLyrics ? `「${sceneLyrics.substring(0, 30)}${sceneLyrics.length > 30 ? '...' : ''}」` : `シーン #${sceneOrder}`;
    
    const modal = Modal.create({
        title: 'シーン削除の確認',
        content: `
            <div class="text-center">
                <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
                    <svg class="h-6 w-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                    </svg>
                </div>
                <h3 class="text-lg font-medium text-gray-900 mb-2">シーンを削除しますか？</h3>
                <p class="text-sm text-gray-500 mb-4">
                    ${displayText} を削除します。<br>
                    この操作は取り消すことができません。
                </p>
            </div>
        `,
        buttons: [
            {
                text: 'キャンセル',
                class: 'btn-secondary',
                action: () => modal.close()
            },
            {
                text: '削除する',
                class: 'btn-danger',
                action: () => {
                    modal.close();
                    deleteScene(sceneId);
                }
            }
        ]
    });
    
    modal.show();
}

/**
 * シーンを削除
 */
async function deleteScene(sceneId) {
    if (!AppState.currentProject || !sceneId) {
        Notification.error('プロジェクトまたはシーンIDが不正です');
        return;
    }
    
    try {
        Loading.show('シーンを削除中...');
        
        // APIでシーンを削除
        const response = await API.delete(`api/scenes.php?id=${sceneId}&project_id=${AppState.currentProject.id}`);
        
        if (response.success) {
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            
            Notification.success('シーンを削除しました');
            
        } else {
            throw new Error(response.error?.message || 'シーンの削除に失敗しました');
        }
        
    } catch (error) {
        console.error('シーン削除エラー:', error);
        Notification.error(`シーンの削除に失敗しました: ${error.message}`);
    } finally {
        Loading.hide();
    }
}

/**
 * ドラッグ&ドロップ機能の設定
 */
function setupDragAndDrop() {
    const sceneRows = document.querySelectorAll('.scene-row');
    let draggedElement = null;
    let draggedIndex = -1;
    
    sceneRows.forEach((row, index) => {
        // ドラッグ開始
        row.addEventListener('dragstart', function(e) {
            draggedElement = this;
            draggedIndex = index;
            this.classList.add('dragging');
            
            // ドラッグ中の視覚的フィードバック
            this.style.opacity = '0.5';
            
            // データ転送の設定
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
        });
        
        // ドラッグ終了
        row.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            this.style.opacity = '';
            
            // すべての行からドロップゾーンクラスを削除
            sceneRows.forEach(r => {
                r.classList.remove('drag-over', 'drop-above', 'drop-below');
            });
        });
        
        // ドラッグオーバー
        row.addEventListener('dragover', function(e) {
            if (draggedElement && draggedElement !== this) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                // ドロップ位置の視覚的フィードバック
                const rect = this.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                
                if (e.clientY < midY) {
                    this.classList.add('drop-above');
                    this.classList.remove('drop-below');
                } else {
                    this.classList.add('drop-below');
                    this.classList.remove('drop-above');
                }
            }
        });
        
        // ドラッグリーブ
        row.addEventListener('dragleave', function(e) {
            this.classList.remove('drag-over', 'drop-above', 'drop-below');
        });
        
        // ドロップ
        row.addEventListener('drop', function(e) {
            e.preventDefault();
            
            if (draggedElement && draggedElement !== this) {
                const targetIndex = Array.from(sceneRows).indexOf(this);
                const rect = this.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                
                // ドロップ位置を決定
                let insertIndex;
                if (e.clientY < midY) {
                    insertIndex = targetIndex;
                } else {
                    insertIndex = targetIndex + 1;
                }
                
                // ドラッグ元のインデックスを調整
                if (draggedIndex < insertIndex) {
                    insertIndex--;
                }
                
                // シーンの並び替えを実行
                reorderScenes(draggedIndex, insertIndex);
            }
            
            this.classList.remove('drag-over', 'drop-above', 'drop-below');
        });
        
        // ドラッグハンドルのクリックでドラッグを開始
        const dragHandle = row.querySelector('.drag-handle');
        if (dragHandle) {
            dragHandle.addEventListener('mousedown', function(e) {
                // ドラッグハンドルがクリックされた時のみドラッグを有効にする
                row.draggable = true;
            });
        }
        
        // その他の場所がクリックされた時はドラッグを無効にする
        row.addEventListener('mousedown', function(e) {
            if (!e.target.closest('.drag-handle')) {
                row.draggable = false;
            }
        });
    });
}

/**
 * シーンの並び替えを実行
 */
async function reorderScenes(fromIndex, toIndex) {
    if (!AppState.currentProject || fromIndex === toIndex) {
        return;
    }
    
    try {
        Loading.show('シーンを並び替え中...');
        
        // 現在のシーン順序を取得
        const sceneRows = document.querySelectorAll('.scene-row');
        const sceneIds = Array.from(sceneRows).map(row => row.dataset.sceneId);
        
        // 配列内で要素を移動
        const movedSceneId = sceneIds.splice(fromIndex, 1)[0];
        sceneIds.splice(toIndex, 0, movedSceneId);
        
        // APIで並び替えを実行
        const response = await API.post('api/scenes.php', {
            action: 'reorder',
            project_id: AppState.currentProject.id,
            scene_ids: sceneIds
        });
        
        if (response.success) {
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            
            Notification.success('シーンの並び替えが完了しました');
            
        } else {
            throw new Error(response.error?.message || 'シーンの並び替えに失敗しました');
        }
        
    } catch (error) {
        console.error('シーン並び替えエラー:', error);
        Notification.error(`シーンの並び替えに失敗しました: ${error.message}`);
        
        // エラー時はシーン一覧を再読み込みして元の状態に戻す
        await loadSceneListView(AppState.currentProject.id);
    } finally {
        Loading.hide();
    }
}

/**
 * シーン詳細編集画面を開く
 */
function openSceneDetail(sceneId) {
    // 後のタスクで実装予定
    console.log('シーン詳細編集:', sceneId);
    Notification.info('シーン詳細編集機能は後のタスクで実装されます');
}

/**
 * ページタイトルを更新
 */
function updatePageTitle(title) {
    const pageTitle = document.getElementById('page-title');
    if (pageTitle) {
        pageTitle.textContent = title;
    }
}

/**
 * API通信用のユーティリティ関数
 */
const API = {
    /**
     * ベースURL
     */
    baseURL: '',
    
    /**
     * 共通リクエスト処理
     */
    request: async function(url, options = {}) {
        const defaultOptions = {
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            }
        };
        
        const mergedOptions = {
            ...defaultOptions,
            ...options,
            headers: {
                ...defaultOptions.headers,
                ...options.headers
            }
        };
        
        try {
            const response = await fetch(this.baseURL + url, mergedOptions);
            
            // レスポンスのステータスチェック
            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
            }
            
            // Content-Typeチェック
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                return data;
            } else {
                const text = await response.text();
                throw new Error(`Unexpected response format: ${text}`);
            }
        } catch (error) {
            console.error('API Request Error:', error);
            throw error;
        }
    },

    /**
     * GET リクエスト
     */
    get: async function(url, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${url}?${queryString}` : url;
        
        return await this.request(fullUrl, {
            method: 'GET'
        });
    },

    /**
     * POST リクエスト
     */
    post: async function(url, data = {}) {
        return await this.request(url, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    },

    /**
     * PUT リクエスト
     */
    put: async function(url, data = {}) {
        return await this.request(url, {
            method: 'PUT',
            body: JSON.stringify(data)
        });
    },

    /**
     * DELETE リクエスト
     */
    delete: async function(url) {
        return await this.request(url, {
            method: 'DELETE'
        });
    }
};

/**
 * ローディング表示ユーティリティ
 */
const Loading = {
    show: function(message = '読み込み中...') {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            const messageElement = overlay.querySelector('span');
            if (messageElement) {
                messageElement.textContent = message;
            }
            overlay.classList.remove('hidden');
        }
    },
    
    hide: function() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            overlay.classList.add('hidden');
        }
    }
};

/**
 * 通知表示ユーティリティ
 */
const Notification = {
    show: function(message, type = 'info', duration = 5000) {
        const container = document.getElementById('notification-container');
        if (!container) return;
        
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        
        const iconMap = {
            success: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>',
            error: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>',
            warning: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path></svg>',
            info: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'
        };
        
        notification.innerHTML = `
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    ${iconMap[type] || iconMap.info}
                </div>
                <div class="ml-3">
                    <p class="text-sm font-medium">${message}</p>
                </div>
                <div class="ml-auto pl-3">
                    <button class="inline-flex text-white hover:text-gray-200 focus:outline-none" onclick="this.parentElement.parentElement.parentElement.remove()">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
        `;
        
        container.appendChild(notification);
        
        // 自動削除
        if (duration > 0) {
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.style.animation = 'slideOut 0.3s ease-in-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, duration);
        }
    },
    
    success: function(message, duration = 5000) {
        this.show(message, 'success', duration);
    },
    
    error: function(message, duration = 8000) {
        this.show(message, 'error', duration);
    },
    
    warning: function(message, duration = 6000) {
        this.show(message, 'warning', duration);
    },
    
    info: function(message, duration = 5000) {
        this.show(message, 'info', duration);
    }
};

/**
 * モーダルダイアログユーティリティ
 */
const Modal = {
    create: function(options) {
        const modal = {
            element: null,
            
            show: function() {
                const container = document.getElementById('modal-container');
                if (!container) return;
                
                this.element = document.createElement('div');
                this.element.className = 'modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4';
                
                const content = document.createElement('div');
                content.className = 'modal-content bg-white rounded-lg shadow-xl max-w-md w-full max-h-screen overflow-y-auto';
                
                let buttonsHTML = '';
                if (options.buttons && options.buttons.length > 0) {
                    buttonsHTML = `
                        <div class="px-6 py-4 bg-gray-50 border-t border-gray-200 flex justify-end space-x-3">
                            ${options.buttons.map(btn => `
                                <button class="px-4 py-2 text-sm font-medium rounded-md transition-colors ${btn.class || 'bg-gray-300 text-gray-700 hover:bg-gray-400'}" 
                                        data-action="${options.buttons.indexOf(btn)}">
                                    ${btn.text}
                                </button>
                            `).join('')}
                        </div>
                    `;
                }
                
                content.innerHTML = `
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-medium text-gray-900">${options.title || 'ダイアログ'}</h3>
                    </div>
                    <div class="px-6 py-4">
                        ${options.content || ''}
                    </div>
                    ${buttonsHTML}
                `;
                
                this.element.appendChild(content);
                container.appendChild(this.element);
                container.classList.remove('hidden');
                
                // ボタンイベントの設定
                if (options.buttons) {
                    content.querySelectorAll('[data-action]').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const actionIndex = parseInt(btn.dataset.action);
                            const button = options.buttons[actionIndex];
                            if (button && button.action) {
                                button.action();
                            }
                        });
                    });
                }
                
                // 背景クリックで閉じる
                this.element.addEventListener('click', (e) => {
                    if (e.target === this.element) {
                        this.close();
                    }
                });
                
                // ESCキーで閉じる
                document.addEventListener('keydown', this.handleEscape);
            },
            
            close: function() {
                if (this.element) {
                    document.removeEventListener('keydown', this.handleEscape);
                    this.element.remove();
                    
                    const container = document.getElementById('modal-container');
                    if (container && !container.hasChildNodes()) {
                        container.classList.add('hidden');
                    }
                }
            },
            
            handleEscape: function(e) {
                if (e.key === 'Escape') {
                    modal.close();
                }
            }
        };
        
        return modal;
    }
};

/**
 * ユーティリティ関数
 */
const Utils = {
    escapeHtml: function(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    formatTime: function(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    },
    
    parseTime: function(timeString) {
        const parts = timeString.split(':');
        if (parts.length === 2) {
            const minutes = parseInt(parts[0]) || 0;
            const seconds = parseInt(parts[1]) || 0;
            return minutes * 60 + seconds;
        }
        return 0;
    }
};

// プロジェクト管理関連の関数（既存のコードから移動）

/**
 * プロジェクト作成モーダルを表示
 */
function showCreateProjectModal() {
    const modal = Modal.create({
        title: '新しいプロジェクトを作成',
        content: `
            <form id="create-project-form" class="space-y-4">
                <div>
                    <label for="project-name" class="block text-sm font-medium text-gray-700 mb-1">曲名</label>
                    <input type="text" id="project-name" name="name" required
                           class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                           placeholder="楽曲名を入力してください">
                </div>
                <div>
                    <label for="project-notes" class="block text-sm font-medium text-gray-700 mb-1">備考</label>
                    <textarea id="project-notes" name="notes" rows="3"
                              class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                              placeholder="プロジェクトの説明や備考を入力してください（任意）"></textarea>
                </div>
            </form>
        `,
        buttons: [
            {
                text: 'キャンセル',
                class: 'px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50',
                action: () => modal.close()
            },
            {
                text: '作成',
                class: 'px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700',
                action: () => {
                    const form = document.getElementById('create-project-form');
                    const formData = new FormData(form);
                    const projectData = {
                        name: formData.get('name'),
                        notes: formData.get('notes') || ''
                    };
                    
                    if (projectData.name.trim()) {
                        modal.close();
                        createProject(projectData);
                    } else {
                        Notification.error('曲名を入力してください');
                    }
                }
            }
        ]
    });
    
    modal.show();
    
    // フォーカスを曲名フィールドに設定
    setTimeout(() => {
        const nameInput = document.getElementById('project-name');
        if (nameInput) {
            nameInput.focus();
        }
    }, 100);
}

/**
 * プロジェクトを作成
 */
async function createProject(projectData) {
    try {
        Loading.show('プロジェクトを作成中...');
        
        const response = await API.post('api/projects.php', projectData);
        
        if (response.success) {
            // プロジェクト一覧を再読み込み
            await loadProjectList();
            
            // 作成したプロジェクトを選択
            if (response.data && response.data.id) {
                await selectProject(response.data.id);
            }
            
            Notification.success(`プロジェクト「${projectData.name}」を作成しました`);
            
        } else {
            throw new Error(response.error?.message || 'プロジェクトの作成に失敗しました');
        }
        
    } catch (error) {
        console.error('プロジェクト作成エラー:', error);
        Notification.error(`プロジェクトの作成に失敗しました: ${error.message}`);
    } finally {
        Loading.hide();
    }
}

/**
 * プロジェクト編集モーダルを表示
 */
function showEditProjectModal(projectId) {
    // 後のタスクで実装予定
    Notification.info('プロジェクト編集機能は後のタスクで実装されます');
}

/**
 * プロジェクト削除確認を表示
 */
function showDeleteProjectConfirm(projectId) {
    // 後のタスクで実装予定
    Notification.info('プロジェクト削除機能は後のタスクで実装されます');
}
    delete: async function(url) {
        return await this.request(url, {
            method: 'DELETE'
        });
    },

    /**
     * ファイルアップロード用POST
     */
    uploadFile: async function(url, formData) {
        try {
            const response = await fetch(this.baseURL + url, {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('File Upload Error:', error);
            throw error;
        }
    }
};

/**
 * 通知表示用のユーティリティ関数
 */
const Notification = {
    container: null,
    
    /**
     * 初期化
     */
    init: function() {
        this.container = document.getElementById('notification-container');
        if (!this.container) {
            this.container = document.createElement('div');
            this.container.id = 'notification-container';
            this.container.className = 'fixed top-4 right-4 z-40 space-y-2';
            document.body.appendChild(this.container);
        }
    },
    
    /**
     * 通知を表示
     */
    show: function(message, type = 'info', duration = 5000) {
        if (!this.container) this.init();
        
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        
        const iconMap = {
            success: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                      </svg>`,
            error: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                     <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                   </svg>`,
            warning: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                       <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path>
                     </svg>`,
            info: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                  </svg>`
        };
        
        notification.innerHTML = `
            <div class="flex items-center">
                <div class="flex-shrink-0 mr-3">
                    ${iconMap[type] || iconMap.info}
                </div>
                <div class="flex-1">
                    <p class="text-sm font-medium">${Utils.escapeHtml(message)}</p>
                </div>
                <button class="ml-3 flex-shrink-0 text-white hover:text-gray-200 transition-colors" onclick="this.parentElement.parentElement.remove()">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
        `;
        
        this.container.appendChild(notification);
        
        // 自動削除
        if (duration > 0) {
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.style.animation = 'slideOut 0.3s ease-in-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, duration);
        }
        
        return notification;
    },
    
    /**
     * 成功メッセージを表示
     */
    success: function(message, duration = 5000) {
        return this.show(message, 'success', duration);
    },

    /**
     * エラーメッセージを表示
     */
    error: function(message, duration = 8000) {
        return this.show(message, 'error', duration);
    },
    
    /**
     * 警告メッセージを表示
     */
    warning: function(message, duration = 6000) {
        return this.show(message, 'warning', duration);
    },
    
    /**
     * 情報メッセージを表示
     */
    info: function(message, duration = 5000) {
        return this.show(message, 'info', duration);
    }
};

/**
 * ローディング表示用のユーティリティ関数
 */
const Loading = {
    overlay: null,
    
    /**
     * ローディングを表示
     */
    show: function(message = '読み込み中...') {
        if (AppState.isLoading) return;
        
        AppState.isLoading = true;
        this.overlay = document.getElementById('loading-overlay');
        
        if (this.overlay) {
            this.overlay.querySelector('span').textContent = message;
            this.overlay.classList.remove('hidden');
        }
    },
    
    /**
     * ローディングを非表示
     */
    hide: function() {
        AppState.isLoading = false;
        
        if (this.overlay) {
            this.overlay.classList.add('hidden');
        }
    }
};

/**
 * ユーティリティ関数
 */
const Utils = {
    /**
     * HTMLエスケープ
     */
    escapeHtml: function(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    /**
     * 日付フォーマット
     */
    formatDate: function(dateString) {
        const date = new Date(dateString);
        return date.toLocaleDateString('ja-JP', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });
    },
    
    /**
     * ファイルサイズフォーマット
     */
    formatFileSize: function(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },
    
    /**
     * デバウンス関数
     */
    debounce: function(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    
    /**
     * スロットル関数
     */
    throttle: function(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },
    
    /**
     * ランダムID生成
     */
    generateId: function(prefix = 'id') {
        return prefix + '_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },
    
    /**
     * 深いオブジェクトコピー
     */
    deepClone: function(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
};

/**
 * エラーハンドリング
 */
window.addEventListener('error', function(e) {
    console.error('Global Error:', e.error);
    Notification.error('予期しないエラーが発生しました');
});

window.addEventListener('unhandledrejection', function(e) {
    console.error('Unhandled Promise Rejection:', e.reason);
    Notification.error('通信エラーが発生しました');
});

/**
 * ページ離脱時の処理
 */
window.addEventListener('beforeunload', function(e) {
    // 未保存の変更があるかチェック
    if (hasUnsavedChanges()) {
        // すべての自動保存タイマーをクリア
        clearAllAutoSaveTimers();
        
        // 未保存の変更を保存（同期的に実行）
        const modifiedFields = document.querySelectorAll('.scene-field.modified');
        modifiedFields.forEach(field => {
            const currentValue = field.value.trim();
            const originalValue = field.dataset.originalValue.trim();
            
            if (currentValue !== originalValue) {
                // バリデーションチェック
                if (field.dataset.field === 'start_time' && !validateTimeFormat(field)) {
                    return;
                }
                
                // 同期的にAPIリクエストを送信（ベストエフォート）
                const updateData = {
                    project_id: AppState.currentProject.id,
                    [field.dataset.field]: currentValue
                };
                
                // sendBeacon APIを使用して確実に送信
                const formData = new FormData();
                formData.append('data', JSON.stringify(updateData));
                formData.append('method', 'PUT');
                formData.append('id', field.dataset.sceneId);
                
                navigator.sendBeacon('api/scenes.php', formData);
            }
        });
        
        // ブラウザに警告メッセージを表示
        const message = '未保存の変更があります。ページを離れますか？';
        e.returnValue = message;
        return message;
    }
});

/**
 * ページ非表示時の処理（モバイル対応）
 */
document.addEventListener('visibilitychange', function() {
    if (document.hidden && hasUnsavedChanges()) {
        // ページが非表示になった時に未保存の変更を保存
        saveAllPendingChanges();
    }
});

/**
 * プロジェクト作成モーダルを表示
 */
function showCreateProjectModal() {
    const modalHTML = `
        <div class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div class="modal-content bg-white rounded-lg shadow-xl max-w-md w-full">
                <div class="px-6 py-4 border-b border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900">新規プロジェクト作成</h3>
                </div>
                <form id="create-project-form" class="p-6 space-y-4">
                    <div>
                        <label for="project-name" class="block text-sm font-medium text-gray-700 mb-2">
                            曲名 <span class="text-red-500">*</span>
                        </label>
                        <input type="text" 
                               id="project-name" 
                               name="name" 
                               required
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                               placeholder="楽曲名を入力してください">
                    </div>
                    <div>
                        <label for="project-notes" class="block text-sm font-medium text-gray-700 mb-2">
                            備考
                        </label>
                        <textarea id="project-notes" 
                                  name="notes" 
                                  rows="3"
                                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                  placeholder="プロジェクトの説明や備考を入力してください（任意）"></textarea>
                    </div>
                </form>
                <div class="px-6 py-4 border-t border-gray-200 flex justify-end space-x-3">
                    <button type="button" 
                            onclick="closeModal()" 
                            class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                        キャンセル
                    </button>
                    <button type="submit" 
                            form="create-project-form"
                            class="px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                        作成
                    </button>
                </div>
            </div>
        </div>
    `;
    
    showModal(modalHTML);
    
    // フォーム送信イベント
    document.getElementById('create-project-form').addEventListener('submit', handleCreateProject);
    
    // 名前フィールドにフォーカス
    setTimeout(() => {
        document.getElementById('project-name').focus();
    }, 100);
}

/**
 * プロジェクト編集モーダルを表示
 */
async function showEditProjectModal(projectId) {
    try {
        Loading.show('プロジェクト情報を読み込み中...');
        
        // プロジェクト情報を取得
        const response = await API.get('api/projects.php', { id: projectId });
        
        if (!response.success) {
            throw new Error(response.error?.message || 'プロジェクト情報の取得に失敗しました');
        }
        
        const project = response.data;
        
        const modalHTML = `
            <div class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                <div class="modal-content bg-white rounded-lg shadow-xl max-w-md w-full">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900">プロジェクト編集</h3>
                    </div>
                    <form id="edit-project-form" class="p-6 space-y-4">
                        <input type="hidden" name="id" value="${project.id}">
                        <div>
                            <label for="edit-project-name" class="block text-sm font-medium text-gray-700 mb-2">
                                曲名 <span class="text-red-500">*</span>
                            </label>
                            <input type="text" 
                                   id="edit-project-name" 
                                   name="name" 
                                   required
                                   value="${Utils.escapeHtml(project.name)}"
                                   class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                   placeholder="楽曲名を入力してください">
                        </div>
                        <div>
                            <label for="edit-project-notes" class="block text-sm font-medium text-gray-700 mb-2">
                                備考
                            </label>
                            <textarea id="edit-project-notes" 
                                      name="notes" 
                                      rows="3"
                                      class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                      placeholder="プロジェクトの説明や備考を入力してください（任意）">${Utils.escapeHtml(project.notes || '')}</textarea>
                        </div>
                    </form>
                    <div class="px-6 py-4 border-t border-gray-200 flex justify-end space-x-3">
                        <button type="button" 
                                onclick="closeModal()" 
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                            キャンセル
                        </button>
                        <button type="submit" 
                                form="edit-project-form"
                                class="px-4 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                            更新
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        showModal(modalHTML);
        
        // フォーム送信イベント
        document.getElementById('edit-project-form').addEventListener('submit', handleEditProject);
        
        // 名前フィールドにフォーカス
        setTimeout(() => {
            document.getElementById('edit-project-name').focus();
        }, 100);
        
    } catch (error) {
        console.error('プロジェクト編集モーダル表示エラー:', error);
        Notification.error('プロジェクト情報の読み込みに失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * プロジェクト削除確認ダイアログを表示
 */
async function showDeleteProjectConfirm(projectId) {
    try {
        Loading.show('プロジェクト情報を読み込み中...');
        
        // プロジェクト情報を取得
        const response = await API.get('api/projects.php', { id: projectId });
        
        if (!response.success) {
            throw new Error(response.error?.message || 'プロジェクト情報の取得に失敗しました');
        }
        
        const project = response.data;
        
        const modalHTML = `
            <div class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                <div class="modal-content bg-white rounded-lg shadow-xl max-w-md w-full">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-semibold text-red-600">プロジェクト削除</h3>
                    </div>
                    <div class="p-6">
                        <div class="flex items-center mb-4">
                            <svg class="w-12 h-12 text-red-500 mr-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path>
                            </svg>
                            <div>
                                <h4 class="text-lg font-medium text-gray-900">本当に削除しますか？</h4>
                                <p class="text-sm text-gray-500 mt-1">この操作は取り消せません。</p>
                            </div>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-4 mb-4">
                            <p class="text-sm text-gray-700">
                                <strong>プロジェクト名:</strong> ${Utils.escapeHtml(project.name)}
                            </p>
                            ${project.notes ? `
                                <p class="text-sm text-gray-700 mt-2">
                                    <strong>備考:</strong> ${Utils.escapeHtml(project.notes)}
                                </p>
                            ` : ''}
                        </div>
                        <p class="text-sm text-red-600 font-medium">
                            ⚠️ プロジェクトに関連するすべてのシーンとメディアファイルも削除されます。
                        </p>
                    </div>
                    <div class="px-6 py-4 border-t border-gray-200 flex justify-end space-x-3">
                        <button type="button" 
                                onclick="closeModal()" 
                                class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                            キャンセル
                        </button>
                        <button type="button" 
                                onclick="handleDeleteProject('${project.id}')"
                                class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors">
                            削除する
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        showModal(modalHTML);
        
    } catch (error) {
        console.error('プロジェクト削除確認ダイアログ表示エラー:', error);
        Notification.error('プロジェクト情報の読み込みに失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * プロジェクト作成処理
 */
async function handleCreateProject(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const projectData = {
        name: formData.get('name').trim(),
        notes: formData.get('notes').trim()
    };
    
    // バリデーション
    if (!projectData.name) {
        Notification.error('曲名を入力してください');
        document.getElementById('project-name').focus();
        return;
    }
    
    try {
        Loading.show('プロジェクトを作成中...');
        
        const response = await API.post('api/projects.php', projectData);
        
        if (!response.success) {
            throw new Error(response.error?.message || 'プロジェクトの作成に失敗しました');
        }
        
        closeModal();
        Notification.success(`プロジェクト「${projectData.name}」を作成しました`);
        
        // プロジェクト一覧を再読み込み
        await loadProjectList();
        
        // 作成したプロジェクトを選択
        if (response.data && response.data.id) {
            await selectProject(response.data.id);
        }
        
    } catch (error) {
        console.error('プロジェクト作成エラー:', error);
        Notification.error('プロジェクトの作成に失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * プロジェクト編集処理
 */
async function handleEditProject(e) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const projectData = {
        id: formData.get('id'),
        name: formData.get('name').trim(),
        notes: formData.get('notes').trim()
    };
    
    // バリデーション
    if (!projectData.name) {
        Notification.error('曲名を入力してください');
        document.getElementById('edit-project-name').focus();
        return;
    }
    
    try {
        Loading.show('プロジェクトを更新中...');
        
        const response = await API.put(`api/projects.php?id=${projectData.id}`, projectData);
        
        if (!response.success) {
            throw new Error(response.error?.message || 'プロジェクトの更新に失敗しました');
        }
        
        closeModal();
        Notification.success(`プロジェクト「${projectData.name}」を更新しました`);
        
        // プロジェクト一覧を再読み込み
        await loadProjectList();
        
        // 現在のプロジェクトが編集されたプロジェクトの場合、情報を更新
        if (AppState.currentProject && AppState.currentProject.id === projectData.id) {
            AppState.currentProject.name = projectData.name;
            AppState.currentProject.notes = projectData.notes;
            updatePageTitle(projectData.name);
        }
        
    } catch (error) {
        console.error('プロジェクト編集エラー:', error);
        Notification.error('プロジェクトの更新に失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * プロジェクト削除処理
 */
async function handleDeleteProject(projectId) {
    try {
        Loading.show('プロジェクトを削除中...');
        
        const response = await API.delete(`api/projects.php?id=${projectId}`);
        
        if (!response.success) {
            throw new Error(response.error?.message || 'プロジェクトの削除に失敗しました');
        }
        
        closeModal();
        Notification.success('プロジェクトを削除しました');
        
        // 削除されたプロジェクトが現在選択中の場合、ウェルカム画面に戻る
        if (AppState.currentProject && AppState.currentProject.id === projectId) {
            AppState.currentProject = null;
            showWelcomeScreen();
        }
        
        // プロジェクト一覧を再読み込み
        await loadProjectList();
        
    } catch (error) {
        console.error('プロジェクト削除エラー:', error);
        Notification.error('プロジェクトの削除に失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * ウェルカム画面を表示
 */
function showWelcomeScreen() {
    const mainContent = document.getElementById('main-content');
    
    const welcomeHTML = `
        <div class="p-6">
            <!-- ウェルカムメッセージ -->
            <div id="welcome-screen" class="text-center py-20">
                <div class="max-w-md mx-auto">
                    <div class="mb-8">
                        <svg class="w-20 h-20 mx-auto text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                    </div>
                    <h3 class="text-2xl font-semibold text-gray-800 mb-4">ミュージックビデオ作成ツール</h3>
                    <p class="text-gray-600 mb-8 leading-relaxed">
                        左のメニューからプロジェクトを選択するか、<br>
                        新しいプロジェクトを作成して始めましょう。
                    </p>
                    <button id="get-started-btn" class="inline-flex items-center px-6 py-3 text-base font-medium text-white bg-primary-600 rounded-lg hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                        </svg>
                        新しいプロジェクトを作成
                    </button>
                </div>
            </div>
        </div>
    `;
    
    mainContent.innerHTML = welcomeHTML;
    updatePageTitle('プロジェクトを選択してください');
    
    // イベントリスナーを再設定
    const getStartedBtn = document.getElementById('get-started-btn');
    if (getStartedBtn) {
        getStartedBtn.addEventListener('click', showCreateProjectModal);
    }
}

/**
 * モーダル表示
 */
function showModal(html) {
    const modalContainer = document.getElementById('modal-container');
    modalContainer.innerHTML = html;
    modalContainer.classList.remove('hidden');
    
    // ESCキーでモーダルを閉じる
    document.addEventListener('keydown', handleModalKeydown);
    
    // モーダル外クリックで閉じる
    modalContainer.addEventListener('click', function(e) {
        if (e.target === modalContainer || e.target.classList.contains('modal-backdrop')) {
            closeModal();
        }
    });
}

/**
 * モーダル閉じる
 */
function closeModal() {
    const modalContainer = document.getElementById('modal-container');
    modalContainer.classList.add('hidden');
    modalContainer.innerHTML = '';
    
    // イベントリスナーを削除
    document.removeEventListener('keydown', handleModalKeydown);
}

/**
 * モーダルキーボードイベント処理
 */
function handleModalKeydown(e) {
    if (e.key === 'Escape') {
        closeModal();
    }
}
/**

 * シーンフィールドの自動保存
 */
async function autoSaveSceneField(fieldElement) {
    const sceneId = fieldElement.dataset.sceneId;
    const fieldName = fieldElement.dataset.field;
    const newValue = fieldElement.value.trim();
    
    if (!sceneId || !fieldName) {
        console.error('シーン保存エラー: シーンIDまたはフィールド名が不正です');
        return false;
    }
    
    // バリデーション
    if (fieldName === 'start_time' && !validateTimeFormat(fieldElement)) {
        return false;
    }
    
    // 既に保存中の場合はスキップ
    if (fieldElement.classList.contains('saving')) {
        return false;
    }
    
    try {
        // 保存中の視覚的フィードバック
        fieldElement.classList.remove('saved', 'save-error', 'modified');
        fieldElement.classList.add('saving');
        showSavingIndicator(fieldElement);
        
        // APIに保存リクエストを送信
        const updateData = {
            project_id: AppState.currentProject.id,
            [fieldName]: newValue
        };
        
        const response = await API.put(`api/scenes.php?id=${sceneId}`, updateData);
        
        if (response.success) {
            // 保存成功
            fieldElement.classList.remove('saving');
            fieldElement.classList.add('saved');
            fieldElement.dataset.originalValue = newValue;
            
            showSaveSuccessIndicator(fieldElement);
            
            // 成功状態を一定時間後にクリア
            setTimeout(() => {
                if (fieldElement.isConnected) {
                    fieldElement.classList.remove('saved');
                    hideSaveIndicator(fieldElement);
                }
            }, 2000);
            
            return true;
            
        } else {
            throw new Error(response.error?.message || 'シーンの保存に失敗しました');
        }
        
    } catch (error) {
        console.error('シーン保存エラー:', error);
        
        // 保存失敗の視覚的フィードバック
        fieldElement.classList.remove('saving');
        fieldElement.classList.add('save-error');
        
        showSaveErrorIndicator(fieldElement);
        
        // エラー通知（デバウンス付き）
        showDebouncedErrorNotification(`保存に失敗しました: ${error.message}`);
        
        // エラー状態を一定時間後にクリア
        setTimeout(() => {
            if (fieldElement.isConnected) {
                fieldElement.classList.remove('save-error');
                hideSaveIndicator(fieldElement);
            }
        }, 5000);
        
        return false;
    }
}

/**
 * デバウンス付きエラー通知
 */
let errorNotificationTimer = null;
function showDebouncedErrorNotification(message) {
    if (errorNotificationTimer) {
        clearTimeout(errorNotificationTimer);
    }
    
    errorNotificationTimer = setTimeout(() => {
        Notification.error(message);
        errorNotificationTimer = null;
    }, 500);
}

/**
 * 未保存の変更があるかチェック
 */
function hasUnsavedChanges() {
    const modifiedFields = document.querySelectorAll('.scene-field.modified, .scene-field.saving');
    return modifiedFields.length > 0;
}

/**
 * すべての未保存変更を保存
 */
async function saveAllPendingChanges() {
    const modifiedFields = document.querySelectorAll('.scene-field.modified');
    const savePromises = [];
    
    modifiedFields.forEach(field => {
        // バリデーションチェック
        if (field.dataset.field === 'start_time' && !validateTimeFormat(field)) {
            return;
        }
        
        const currentValue = field.value.trim();
        const originalValue = field.dataset.originalValue.trim();
        
        if (currentValue !== originalValue) {
            savePromises.push(autoSaveSceneField(field));
        }
    });
    
    if (savePromises.length > 0) {
        try {
            await Promise.all(savePromises);
            console.log('すべての変更が保存されました');
        } catch (error) {
            console.error('一部の変更の保存に失敗しました:', error);
        }
    }
}

/**
 * 保存中インジケーターの表示
 */
function showSavingIndicator(fieldElement) {
    hideSaveIndicator(fieldElement); // 既存のインジケーターを削除
    
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator saving-indicator';
    indicator.innerHTML = `
        <svg class="w-4 h-4 text-blue-600 loading" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
    `;
    indicator.title = '保存中...';
    
    const container = fieldElement.closest('td');
    if (container) {
        container.style.position = 'relative';
        container.appendChild(indicator);
    }
}

/**
 * 保存成功インジケーターの表示
 */
function showSaveSuccessIndicator(fieldElement) {
    hideSaveIndicator(fieldElement); // 既存のインジケーターを削除
    
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator success-indicator';
    indicator.innerHTML = `
        <svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
        </svg>
    `;
    indicator.title = '保存完了';
    
    const container = fieldElement.closest('td');
    if (container) {
        container.style.position = 'relative';
        container.appendChild(indicator);
    }
}

/**
 * 保存エラーインジケーターの表示
 */
function showSaveErrorIndicator(fieldElement) {
    hideSaveIndicator(fieldElement); // 既存のインジケーターを削除
    
    const indicator = document.createElement('div');
    indicator.className = 'save-indicator error-indicator';
    indicator.innerHTML = `
        <svg class="w-4 h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
    `;
    indicator.title = '保存失敗';
    
    const container = fieldElement.closest('td');
    if (container) {
        container.style.position = 'relative';
        container.appendChild(indicator);
    }
}

/**
 * 保存インジケーターの非表示
 */
function hideSaveIndicator(fieldElement) {
    const container = fieldElement.closest('td');
    if (container) {
        const existingIndicator = container.querySelector('.save-indicator');
        if (existingIndicator) {
            existingIndicator.remove();
        }
    }
}

/**
 * ユーティリティ関数
 */
const Utils = {
    /**
     * HTMLエスケープ
     */
    escapeHtml: function(text) {
        if (typeof text !== 'string') return text;
        
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    /**
     * 時間文字列を秒数に変換
     */
    timeToSeconds: function(timeStr) {
        if (!timeStr) return 0;
        
        const parts = timeStr.split(':');
        if (parts.length !== 2) return 0;
        
        const minutes = parseInt(parts[0]) || 0;
        const seconds = parseInt(parts[1]) || 0;
        
        return minutes * 60 + seconds;
    },
    
    /**
     * 秒数を時間文字列に変換
     */
    secondsToTime: function(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    },
    
    /**
     * ファイルサイズを人間が読みやすい形式に変換
     */
    formatFileSize: function(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },
    
    /**
     * デバウンス関数
     */
    debounce: function(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    
    /**
     * スロットル関数
     */
    throttle: function(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
};

// ページ離脱時の未保存変更チェック
window.addEventListener('beforeunload', function(e) {
    if (hasUnsavedChanges()) {
        e.preventDefault();
        e.returnValue = '未保存の変更があります。ページを離れますか？';
        return e.returnValue;
    }
});

// 定期的な自動保存（5分間隔）
setInterval(async () => {
    if (hasUnsavedChanges()) {
        console.log('定期自動保存を実行中...');
        await saveAllPendingChanges();
    }
}, 5 * 60 * 1000); // 5分
/*
*
 * シーン一覧のイベントリスナー設定
 */
function setupSceneListEventListeners() {
    // シーン追加ボタン
    const addSceneBtn = document.getElementById('add-scene-btn');
    if (addSceneBtn) {
        addSceneBtn.addEventListener('click', addNewScene);
    }
    
    // ファイルアップロードボタン
    const uploadScenesBtn = document.getElementById('upload-scenes-btn');
    if (uploadScenesBtn) {
        uploadScenesBtn.addEventListener('click', () => {
            // 後のタスクで実装予定
            Notification.info('ファイルアップロード機能は後のタスクで実装されます');
        });
    }
    
    // シーンフィールドのインライン編集
    setupSceneFieldEditing();
    
    // ドラッグ&ドロップ機能の初期化
    setupSceneDragAndDrop();
    
    // シーン削除ボタン
    const deleteButtons = document.querySelectorAll('.delete-scene-btn');
    deleteButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const sceneId = this.dataset.sceneId;
            showDeleteSceneConfirm(sceneId);
        });
    });
}

/**
 * シーンフィールドのインライン編集設定
 */
function setupSceneFieldEditing() {
    const sceneFields = document.querySelectorAll('.scene-field');
    sceneFields.forEach(field => {
        // 元の値を保存
        field.dataset.originalValue = field.value;
        
        // フォーカス時の処理
        field.addEventListener('focus', function() {
            this.classList.add('editing');
            this.closest('tr').classList.add('editing-row');
            this.dataset.originalValue = this.value;
            
            // バリデーションエラーをクリア
            hideValidationError(this);
            hideSaveIndicator(this);
            
            // フォーカス時にテキストを選択（開始時間フィールドのみ）
            if (this.dataset.field === 'start_time' && this.value) {
                setTimeout(() => this.select(), 0);
            }
        });
        
        // フォーカス離脱時の処理
        field.addEventListener('blur', function() {
            this.classList.remove('editing');
            this.closest('tr').classList.remove('editing-row');
            
            // 値が変更されている場合のみ自動保存
            const currentValue = this.value.trim();
            const originalValue = this.dataset.originalValue.trim();
            
            if (currentValue !== originalValue) {
                // バリデーションチェック
                if (this.dataset.field === 'start_time' && !validateTimeFormat(this)) {
                    // バリデーションエラーの場合は保存しない
                    return;
                }
                
                autoSaveSceneField(this);
            } else {
                // 変更がない場合は状態をクリア
                this.classList.remove('modified', 'saving', 'saved', 'save-error');
                hideValidationError(this);
                hideSaveIndicator(this);
            }
        });
        
        // キーボードイベントの処理
        field.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                
                // バリデーションチェック
                if (this.dataset.field === 'start_time' && !validateTimeFormat(this)) {
                    return; // バリデーションエラーの場合は移動しない
                }
                
                // 現在の値を保存してから次のフィールドに移動
                const currentValue = this.value.trim();
                const originalValue = this.dataset.originalValue.trim();
                
                if (currentValue !== originalValue) {
                    autoSaveSceneField(this);
                }
                
                // 次のフィールドに移動
                moveToNextField(this);
                
            } else if (e.key === 'Escape') {
                // Escapeキーで変更をキャンセル
                this.value = this.dataset.originalValue;
                this.classList.remove('modified', 'invalid');
                hideValidationError(this);
                hideSaveIndicator(this);
                this.blur();
                
            } else if (e.key === 'Tab') {
                // Tabキーでの移動時も保存
                const currentValue = this.value.trim();
                const originalValue = this.dataset.originalValue.trim();
                
                if (currentValue !== originalValue) {
                    if (this.dataset.field === 'start_time' && !validateTimeFormat(this)) {
                        e.preventDefault();
                        return;
                    }
                    autoSaveSceneField(this);
                }
            }
        });
        
        // 入力時のリアルタイム処理
        field.addEventListener('input', function() {
            // リアルタイムバリデーション
            if (this.dataset.field === 'start_time') {
                validateTimeFormat(this);
            }
            
            // 変更状態の視覚的表示
            const currentValue = this.value.trim();
            const originalValue = this.dataset.originalValue.trim();
            
            if (currentValue !== originalValue) {
                this.classList.add('modified');
                this.classList.remove('saved', 'save-error');
                
                // デバウンス付き自動保存をスケジュール
                scheduleAutoSave(this);
            } else {
                this.classList.remove('modified', 'saved', 'save-error');
                hideValidationError(this);
                hideSaveIndicator(this);
                
                // 自動保存をキャンセル
                cancelAutoSave(this);
            }
        });
        
        // 時間フィールドの特別な処理
        if (field.dataset.field === 'start_time') {
            // 数字キーと特定の記号のみ許可
            field.addEventListener('keypress', function(e) {
                const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':'];
                const specialKeys = ['Backspace', 'Delete', 'Tab', 'Escape', 'Enter', 'ArrowLeft', 'ArrowRight'];
                
                if (!allowedKeys.includes(e.key) && !specialKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                }
            });
        }
    });
}

/**
 * ドラッグ&ドロップ機能の設定
 */
function setupSceneDragAndDrop() {
    const sceneRows = document.querySelectorAll('.scene-row');
    
    sceneRows.forEach(row => {
        // ドラッグ可能に設定
        row.draggable = true;
        
        // ドラッグハンドルのイベント
        const dragHandle = row.querySelector('.drag-handle');
        if (dragHandle) {
            dragHandle.addEventListener('mousedown', function(e) {
                // ドラッグハンドルがクリックされた時のみドラッグを有効にする
                row.setAttribute('data-drag-enabled', 'true');
            });
        }
        
        // ドラッグ開始
        row.addEventListener('dragstart', function(e) {
            // ドラッグハンドル以外からのドラッグは無効
            if (!row.hasAttribute('data-drag-enabled')) {
                e.preventDefault();
                return;
            }
            
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.sceneId);
            
            // ドラッグ中の視覚的フィードバック
            setTimeout(() => {
                this.style.opacity = '0.5';
            }, 0);
        });
        
        // ドラッグ終了
        row.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            this.style.opacity = '';
            this.removeAttribute('data-drag-enabled');
            
            // すべてのドロップインジケーターをクリア
            clearDropIndicators();
        });
        
        // ドラッグオーバー
        row.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const draggingElement = document.querySelector('.scene-row.dragging');
            if (draggingElement && draggingElement !== this) {
                // ドロップ位置を決定
                const rect = this.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                const dropPosition = e.clientY < midpoint ? 'above' : 'below';
                
                // ドロップインジケーターを更新
                updateDropIndicators(this, dropPosition);
            }
        });
        
        // ドラッグリーブ
        row.addEventListener('dragleave', function(e) {
            // 要素から完全に離れた場合のみクリア
            if (!this.contains(e.relatedTarget)) {
                clearDropIndicators();
            }
        });
        
        // ドロップ
        row.addEventListener('drop', function(e) {
            e.preventDefault();
            
            const draggedSceneId = e.dataTransfer.getData('text/plain');
            const draggedElement = document.querySelector(`[data-scene-id="${draggedSceneId}"]`);
            
            if (draggedElement && draggedElement !== this) {
                // ドロップ位置を決定
                const rect = this.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                const dropPosition = e.clientY < midpoint ? 'above' : 'below';
                
                // シーンの並び替えを実行
                reorderScenes(draggedSceneId, this.dataset.sceneId, dropPosition);
            }
            
            clearDropIndicators();
        });
    });
}

/**
 * ドロップインジケーターの更新
 */
function updateDropIndicators(targetRow, position) {
    clearDropIndicators();
    
    if (position === 'above') {
        targetRow.classList.add('drop-above');
    } else {
        targetRow.classList.add('drop-below');
    }
}

/**
 * ドロップインジケーターのクリア
 */
function clearDropIndicators() {
    const rows = document.querySelectorAll('.scene-row');
    rows.forEach(row => {
        row.classList.remove('drop-above', 'drop-below', 'drag-over');
    });
}

/**
 * シーンの並び替え実行
 */
async function reorderScenes(draggedSceneId, targetSceneId, position) {
    try {
        Loading.show('シーンを並び替え中...');
        
        // 現在のシーン一覧を取得
        const sceneRows = Array.from(document.querySelectorAll('.scene-row'));
        const sceneIds = sceneRows.map(row => row.dataset.sceneId);
        
        // ドラッグされたシーンのインデックスを取得
        const draggedIndex = sceneIds.indexOf(draggedSceneId);
        const targetIndex = sceneIds.indexOf(targetSceneId);
        
        if (draggedIndex === -1 || targetIndex === -1) {
            throw new Error('シーンが見つかりません');
        }
        
        // 新しい順序を計算
        const newOrder = [...sceneIds];
        
        // ドラッグされた要素を削除
        newOrder.splice(draggedIndex, 1);
        
        // 新しい位置に挿入
        let insertIndex = targetIndex;
        if (draggedIndex < targetIndex) {
            insertIndex--; // 削除により位置が前にずれる
        }
        if (position === 'below') {
            insertIndex++;
        }
        
        newOrder.splice(insertIndex, 0, draggedSceneId);
        
        // APIに並び替えリクエストを送信
        const response = await API.post('api/scenes.php', {
            action: 'reorder',
            project_id: AppState.currentProject.id,
            scene_ids: newOrder
        });
        
        if (!response.success) {
            throw new Error(response.error?.message || '並び替えに失敗しました');
        }
        
        // シーン一覧を再読み込み
        await loadSceneListView(AppState.currentProject.id);
        
        Notification.success('シーンの並び替えが完了しました');
        
    } catch (error) {
        console.error('シーン並び替えエラー:', error);
        Notification.error('シーンの並び替えに失敗しました: ' + error.message);
        
        // エラー時はシーン一覧を再読み込みして元の状態に戻す
        await loadSceneListView(AppState.currentProject.id);
    } finally {
        Loading.hide();
    }
}

/**
 * 新しいシーンを追加
 */
async function addNewScene() {
    try {
        Loading.show('シーンを追加中...');
        
        const response = await API.post('api/scenes.php', {
            project_id: AppState.currentProject.id,
            start_time: '0:00',
            lyrics: '',
            description: '',
            image_prompt: '',
            video_prompt: ''
        });
        
        if (!response.success) {
            throw new Error(response.error?.message || 'シーンの追加に失敗しました');
        }
        
        // シーン一覧を再読み込み
        await loadSceneListView(AppState.currentProject.id);
        
        Notification.success('新しいシーンを追加しました');
        
        // 追加されたシーンの最初のフィールドにフォーカス
        setTimeout(() => {
            const newSceneRow = document.querySelector(`[data-scene-id="${response.data.id}"]`);
            if (newSceneRow) {
                const firstField = newSceneRow.querySelector('.scene-field');
                if (firstField) {
                    firstField.focus();
                }
            }
        }, 100);
        
    } catch (error) {
        console.error('シーン追加エラー:', error);
        Notification.error('シーンの追加に失敗しました: ' + error.message);
    } finally {
        Loading.hide();
    }
}

/**
 * シーン削除確認ダイアログ
 */
function showDeleteSceneConfirm(sceneId) {
    const sceneRow = document.querySelector(`[data-scene-id="${sceneId}"]`);
    if (!sceneRow) return;
    
    const sceneOrder = sceneRow.querySelector('.scene-field[data-field="start_time"]')?.value || '';
    const sceneLyrics = sceneRow.querySelector('.scene-field[data-field="lyrics"]')?.value || '';
    
    const modal = Modal.create({
        title: 'シーンの削除',
        content: `
            <div class="text-center">
                <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
                    <svg class="h-6 w-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path>
                    </svg>
                </div>
                <h3 class="text-lg font-medium text-gray-900 mb-2">本当に削除しますか？</h3>
                <div class="text-sm text-gray-500 mb-4">
                    <p><strong>開始時間:</strong> ${sceneOrder || '未設定'}</p>
                    <p><strong>歌詞:</strong> ${sceneLyrics ? sceneLyrics.substring(0, 50) + (sceneLyrics.length > 50 ? '...' : '') : '未設定'}</p>
                </div>
                <p class="text-sm text-gray-600">この操作は取り消せません。</p>
            </div>
        `,
        buttons: [
            {
                text: 'キャンセル',
                class: 'btn-secondary',
                action: () => modal.close()
            },
            {
                text: '削除する',
                class: 'btn-danger',
                action: () => {
                    modal.close();
                    deleteScene(sceneId);
                }
            }
        ]
    });
    
    modal.show();
}

/**
 * シーンを削除
 */
async function deleteScene(sceneId) {
    try {
        Loading.show('シーンを削除中...');
        
        const response = await API.delete('api/scenes.php', {
            id: sceneId,
            project_id: AppState.currentProject.id
        });
        
        if (!response.success) {
            throw new Error(response.error?.message || 'シーンの削除に失敗しました');
        }
        
        // シーン一覧を再読み込み
        await loadSceneListView(AppState.currentProject.id);
        
        Notification.success('シーンを削除しました');
        
    } catch (error) {
        console.error('シーン削除エラー:', error);
        Notification.error('シーンの削除に失敗しました: ' + error.message);
    } finally {
        Loading.hide();
    }
}

/**
 * シーンフィールドの自動保存
 */
async function autoSaveSceneField(field) {
    const sceneId = field.dataset.sceneId;
    const fieldName = field.dataset.field;
    const value = field.value.trim();
    
    try {
        // 保存状態の表示
        field.classList.remove('modified', 'saved', 'save-error');
        field.classList.add('saving');
        showSaveIndicator(field, 'saving');
        
        const updateData = {
            project_id: AppState.currentProject.id,
            [fieldName]: value
        };
        
        const response = await API.put(`api/scenes.php?id=${sceneId}`, updateData);
        
        if (!response.success) {
            throw new Error(response.error?.message || '保存に失敗しました');
        }
        
        // 保存成功
        field.classList.remove('saving');
        field.classList.add('saved');
        field.dataset.originalValue = value;
        showSaveIndicator(field, 'success');
        
        // 成功インジケーターを2秒後に非表示
        setTimeout(() => {
            field.classList.remove('saved');
            hideSaveIndicator(field);
        }, 2000);
        
    } catch (error) {
        console.error('自動保存エラー:', error);
        
        // 保存エラー
        field.classList.remove('saving');
        field.classList.add('save-error');
        showSaveIndicator(field, 'error');
        
        // エラーメッセージを表示
        showValidationError(field, '保存に失敗しました: ' + error.message);
        
        // エラー状態を5秒後にクリア
        setTimeout(() => {
            field.classList.remove('save-error');
            hideSaveIndicator(field);
            hideValidationError(field);
        }, 5000);
    }
}

/**
 * 時間フォーマットのバリデーション
 */
function validateTimeFormat(field) {
    const value = field.value.trim();
    const timePattern = /^(\d{1,2}):([0-5]\d)$/;
    
    if (value === '') {
        // 空の場合は有効
        field.classList.remove('invalid');
        hideValidationError(field);
        return true;
    }
    
    if (!timePattern.test(value)) {
        field.classList.add('invalid');
        showValidationError(field, '時間は M:SS または MM:SS の形式で入力してください（例: 1:30, 12:45）');
        return false;
    }
    
    field.classList.remove('invalid');
    hideValidationError(field);
    return true;
}

/**
 * バリデーションエラーの表示
 */
function showValidationError(field, message) {
    hideValidationError(field);
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error absolute z-20 mt-1 p-2 text-xs text-red-600 bg-red-50 border border-red-200 rounded shadow-lg';
    errorDiv.textContent = message;
    errorDiv.id = `error-${field.dataset.sceneId}-${field.dataset.field}`;
    
    const container = field.closest('td');
    container.style.position = 'relative';
    container.appendChild(errorDiv);
}

/**
 * バリデーションエラーの非表示
 */
function hideValidationError(field) {
    const errorId = `error-${field.dataset.sceneId}-${field.dataset.field}`;
    const errorDiv = document.getElementById(errorId);
    if (errorDiv) {
        errorDiv.remove();
    }
}

/**
 * 保存インジケーターの表示
 */
function showSaveIndicator(field, type) {
    hideSaveIndicator(field);
    
    const indicator = document.createElement('div');
    indicator.className = `save-indicator ${type}-indicator`;
    indicator.id = `indicator-${field.dataset.sceneId}-${field.dataset.field}`;
    
    let icon = '';
    if (type === 'saving') {
        icon = '<svg class="w-4 h-4 text-blue-600 loading" fill="none" stroke="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" class="opacity-25"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
    } else if (type === 'success') {
        icon = '<svg class="w-4 h-4 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>';
    } else if (type === 'error') {
        icon = '<svg class="w-4 h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>';
    }
    
    indicator.innerHTML = icon;
    
    const container = field.closest('td');
    container.style.position = 'relative';
    container.appendChild(indicator);
}

/**
 * 保存インジケーターの非表示
 */
function hideSaveIndicator(field) {
    const indicatorId = `indicator-${field.dataset.sceneId}-${field.dataset.field}`;
    const indicator = document.getElementById(indicatorId);
    if (indicator) {
        indicator.remove();
    }
}

/**
 * 次のフィールドに移動
 */
function moveToNextField(currentField) {
    const currentRow = currentField.closest('tr');
    const fields = currentRow.querySelectorAll('.scene-field');
    const currentIndex = Array.from(fields).indexOf(currentField);
    
    if (currentIndex < fields.length - 1) {
        // 同じ行の次のフィールド
        fields[currentIndex + 1].focus();
    } else {
        // 次の行の最初のフィールド
        const nextRow = currentRow.nextElementSibling;
        if (nextRow && nextRow.classList.contains('scene-row')) {
            const nextField = nextRow.querySelector('.scene-field');
            if (nextField) {
                nextField.focus();
            }
        }
    }
}

/**
 * デバウンス付き自動保存のスケジュール
 */
const autoSaveTimeouts = new Map();

function scheduleAutoSave(field) {
    const key = `${field.dataset.sceneId}-${field.dataset.field}`;
    
    // 既存のタイマーをクリア
    if (autoSaveTimeouts.has(key)) {
        clearTimeout(autoSaveTimeouts.get(key));
    }
    
    // 新しいタイマーを設定（1秒後に自動保存）
    const timeoutId = setTimeout(() => {
        const currentValue = field.value.trim();
        const originalValue = field.dataset.originalValue.trim();
        
        if (currentValue !== originalValue) {
            // バリデーションチェック
            if (field.dataset.field === 'start_time' && !validateTimeFormat(field)) {
                return;
            }
            
            autoSaveSceneField(field);
        }
        
        autoSaveTimeouts.delete(key);
    }, 1000);
    
    autoSaveTimeouts.set(key, timeoutId);
}

/**
 * 自動保存のキャンセル
 */
function cancelAutoSave(field) {
    const key = `${field.dataset.sceneId}-${field.dataset.field}`;
    
    if (autoSaveTimeouts.has(key)) {
        clearTimeout(autoSaveTimeouts.get(key));
        autoSaveTimeouts.delete(key);
    }
}

/**
 * シーン詳細編集画面を開く
 */
function openSceneDetail(sceneId) {
    // 後のタスクで実装予定
    Notification.info('シーン詳細編集機能は後のタスクで実装されます');
}

/**
 * ページタイトルの更新
 */
function updatePageTitle(title) {
    const pageTitle = document.getElementById('page-title');
    if (pageTitle) {
        pageTitle.textContent = title;
    }
}
/**

 * API通信ユーティリティ
 */
const API = {
    /**
     * GET リクエスト
     */
    async get(url, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${url}?${queryString}` : url;
        
        try {
            const response = await fetch(fullUrl, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            return await response.json();
        } catch (error) {
            console.error('API GET Error:', error);
            return { success: false, error: { message: 'ネットワークエラーが発生しました' } };
        }
    },
    
    /**
     * POST リクエスト
     */
    async post(url, data = {}) {
        try {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
            return await response.json();
        } catch (error) {
            console.error('API POST Error:', error);
            return { success: false, error: { message: 'ネットワークエラーが発生しました' } };
        }
    },
    
    /**
     * PUT リクエスト
     */
    async put(url, data = {}) {
        try {
            const response = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            
            return await response.json();
        } catch (error) {
            console.error('API PUT Error:', error);
            return { success: false, error: { message: 'ネットワークエラーが発生しました' } };
        }
    },
    
    /**
     * DELETE リクエスト
     */
    async delete(url, params = {}) {
        const queryString = new URLSearchParams(params).toString();
        const fullUrl = queryString ? `${url}?${queryString}` : url;
        
        try {
            const response = await fetch(fullUrl, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            return await response.json();
        } catch (error) {
            console.error('API DELETE Error:', error);
            return { success: false, error: { message: 'ネットワークエラーが発生しました' } };
        }
    }
};

/**
 * ローディング表示ユーティリティ
 */
const Loading = {
    show(message = '読み込み中...') {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            const messageElement = overlay.querySelector('span');
            if (messageElement) {
                messageElement.textContent = message;
            }
            overlay.classList.remove('hidden');
        }
    },
    
    hide() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            overlay.classList.add('hidden');
        }
    }
};

/**
 * 通知表示ユーティリティ
 */
const Notification = {
    show(message, type = 'info', duration = 5000) {
        const container = document.getElementById('notification-container');
        if (!container) return;
        
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        
        const iconMap = {
            success: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>',
            error: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>',
            warning: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path></svg>',
            info: '<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>'
        };
        
        notification.innerHTML = `
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    ${iconMap[type] || iconMap.info}
                </div>
                <div class="ml-3 flex-1">
                    <p class="text-sm font-medium">${message}</p>
                </div>
                <div class="ml-4 flex-shrink-0">
                    <button class="inline-flex text-white hover:text-gray-200 focus:outline-none" onclick="this.parentElement.parentElement.parentElement.remove()">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>
        `;
        
        container.appendChild(notification);
        
        // 自動削除
        if (duration > 0) {
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.style.animation = 'slideOut 0.3s ease-in-out';
                    setTimeout(() => notification.remove(), 300);
                }
            }, duration);
        }
    },
    
    success(message, duration = 5000) {
        this.show(message, 'success', duration);
    },
    
    error(message, duration = 8000) {
        this.show(message, 'error', duration);
    },
    
    warning(message, duration = 6000) {
        this.show(message, 'warning', duration);
    },
    
    info(message, duration = 5000) {
        this.show(message, 'info', duration);
    }
};

/**
 * モーダルダイアログユーティリティ
 */
const Modal = {
    create(options) {
        const modal = {
            element: null,
            
            show() {
                const container = document.getElementById('modal-container');
                if (!container) return;
                
                this.element = document.createElement('div');
                this.element.className = 'modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4';
                
                const content = document.createElement('div');
                content.className = 'modal-content bg-white rounded-lg shadow-xl max-w-md w-full max-h-screen overflow-y-auto';
                
                const header = document.createElement('div');
                header.className = 'px-6 py-4 border-b border-gray-200';
                header.innerHTML = `<h3 class="text-lg font-medium text-gray-900">${options.title || ''}</h3>`;
                
                const body = document.createElement('div');
                body.className = 'px-6 py-4';
                body.innerHTML = options.content || '';
                
                const footer = document.createElement('div');
                footer.className = 'px-6 py-4 border-t border-gray-200 flex justify-end space-x-3';
                
                if (options.buttons) {
                    options.buttons.forEach(button => {
                        const btn = document.createElement('button');
                        btn.className = `px-4 py-2 text-sm font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 ${button.class || 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`;
                        btn.textContent = button.text || 'OK';
                        btn.addEventListener('click', button.action || (() => this.close()));
                        footer.appendChild(btn);
                    });
                }
                
                content.appendChild(header);
                content.appendChild(body);
                if (options.buttons) {
                    content.appendChild(footer);
                }
                
                this.element.appendChild(content);
                container.appendChild(this.element);
                container.classList.remove('hidden');
                
                // ESCキーで閉じる
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        this.close();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
                
                // 背景クリックで閉じる
                this.element.addEventListener('click', (e) => {
                    if (e.target === this.element) {
                        this.close();
                    }
                });
            },
            
            close() {
                if (this.element) {
                    this.element.remove();
                    const container = document.getElementById('modal-container');
                    if (container && !container.hasChildNodes()) {
                        container.classList.add('hidden');
                    }
                }
            }
        };
        
        return modal;
    }
};

/**
 * ユーティリティ関数
 */
const Utils = {
    /**
     * HTMLエスケープ
     */
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },
    
    /**
     * 時間文字列を秒に変換
     */
    timeToSeconds(timeStr) {
        const parts = timeStr.split(':');
        if (parts.length !== 2) return 0;
        
        const minutes = parseInt(parts[0], 10) || 0;
        const seconds = parseInt(parts[1], 10) || 0;
        
        return minutes * 60 + seconds;
    },
    
    /**
     * 秒を時間文字列に変換
     */
    secondsToTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    },
    
    /**
     * ファイルサイズを人間が読みやすい形式に変換
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },
    
    /**
     * デバウンス関数
     */
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
};/**
 * 
シーン行の描画
 */
function renderSceneRows(scenes) {
    if (!scenes || scenes.length === 0) {
        return '';
    }
    
    return scenes.map((scene, index) => `
        <tr class="scene-row hover:bg-gray-50 transition-colors" data-scene-id="${scene.id}" data-order="${scene.order || index + 1}" draggable="true">
            <td class="px-6 py-4 whitespace-nowrap relative">
                <div class="flex items-center">
                    <div class="drag-handle mr-2 cursor-move text-gray-400 hover:text-gray-600" title="ドラッグして並び替え">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path>
                        </svg>
                    </div>
                    <div class="w-16 h-12 bg-gray-200 rounded-md flex items-center justify-center cursor-pointer hover:bg-gray-300 transition-colors shadow-sm" 
                         onclick="openSceneDetail('${scene.id}')" title="詳細編集画面を開く">
                        ${scene.image_file_id ? 
                            `<img src="data/projects/${AppState.currentProject.id}/media/images/${scene.image_file_id}" 
                                  class="w-full h-full object-cover rounded-md" alt="シーン${scene.order || index + 1}のサムネイル"
                                  onerror="this.parentElement.innerHTML='<svg class=\\"w-6 h-6 text-gray-400\\" fill=\\"none\\" stroke=\\"currentColor\\" viewBox=\\"0 0 24 24\\"><path stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\\"></path></svg>'">` :
                            `<svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>`
                        }
                    </div>
                </div>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
                <input type="text" 
                       class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded transition-colors" 
                       data-field="start_time" 
                       data-scene-id="${scene.id}"
                       value="${Utils.escapeHtml(scene.start_time || '')}"
                       placeholder="0:00"
                       pattern="[0-9]+:[0-5][0-9]"
                       title="時間形式: M:SS または MM:SS">
            </td>
            <td class="px-6 py-4">
                <textarea class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded resize-none transition-colors" 
                          data-field="lyrics" 
                          data-scene-id="${scene.id}"
                          rows="2"
                          placeholder="歌詞を入力..."
                          title="このシーンの歌詞部分">${Utils.escapeHtml(scene.lyrics || '')}</textarea>
            </td>
            <td class="px-6 py-4">
                <textarea class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded resize-none transition-colors" 
                          data-field="description" 
                          data-scene-id="${scene.id}"
                          rows="2"
                          placeholder="シーン説明を入力..."
                          title="映像の内容やコンセプトの説明">${Utils.escapeHtml(scene.description || '')}</textarea>
            </td>
            <td class="px-6 py-4">
                <textarea class="scene-field w-full px-2 py-1 text-sm border-0 bg-transparent hover:bg-gray-50 focus:bg-white focus:border-primary-300 focus:ring-1 focus:ring-primary-300 rounded resize-none transition-colors" 
                          data-field="image_prompt" 
                          data-scene-id="${scene.id}"
                          rows="2"
                          placeholder="英語プロンプトを入力..."
                          title="AI画像生成用の英語プロンプト">${Utils.escapeHtml(scene.image_prompt || '')}</textarea>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <div class="flex items-center justify-end space-x-2">
                    <span class="text-xs text-gray-400 mr-2">#${scene.order || index + 1}</span>
                    <button class="delete-scene-btn p-1 text-red-600 hover:text-red-900 hover:bg-red-50 rounded transition-colors" 
                            data-scene-id="${scene.id}" 
                            title="シーンを削除">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                </div>
            </td>
        </tr>
    `).join('');
}
/**
 
* メディアライブラリ画面を読み込み
 */
async function loadMediaLibraryView() {
    if (!AppState.currentProject) {
        Notification.error('プロジェクトが選択されていません');
        return;
    }
    
    try {
        Loading.show('メディアライブラリを読み込み中...');
        
        // メディアファイル一覧を取得
        const mediaResponse = await API.get('api/media.php', { 
            project_id: AppState.currentProject.id 
        });
        
        if (!mediaResponse.success) {
            throw new Error(mediaResponse.error?.message || 'メディアファイルの読み込みに失敗しました');
        }
        
        // メディアライブラリ画面を描画
        renderMediaLibraryView(mediaResponse.data || []);
        
        // ページタイトルを更新
        updatePageTitle('メディアライブラリ - ' + AppState.currentProject.name);
        
        Notification.success('メディアライブラリを読み込みました');
        
    } catch (error) {
        console.error('メディアライブラリ読み込みエラー:', error);
        Notification.error('メディアライブラリの読み込みに失敗しました');
        
        // エラー時は空のメディアライブラリを表示
        renderMediaLibraryView([]);
    } finally {
        Loading.hide();
    }
}

/**
 * メディアライブラリ画面の描画
 */
function renderMediaLibraryView(mediaFiles) {
    const mainContent = document.getElementById('main-content');
    
    const mediaLibraryHTML = `
        <div class="p-6">
            <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                <!-- ヘッダー -->
                <div class="px-6 py-4 border-b border-gray-200 bg-gradient-to-r from-gray-50 to-white">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="text-lg font-semibold text-gray-900">メディアライブラリ</h3>
                            <p class="text-sm text-gray-500 mt-1">
                                プロジェクト: ${Utils.escapeHtml(AppState.currentProject?.name || '')} 
                                ${mediaFiles.length > 0 ? `(${mediaFiles.length}ファイル)` : ''}
                            </p>
                        </div>
                        <div class="flex items-center space-x-3">
                            <button id="back-to-scenes-btn" class="inline-flex items-center px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                                </svg>
                                シーン一覧に戻る
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- フィルタ -->
                <div class="px-6 py-3 border-b border-gray-200 bg-gray-50">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-4">
                            <span class="text-sm font-medium text-gray-700">表示フィルタ:</span>
                            <div class="flex items-center space-x-2">
                                <button id="filter-all" class="filter-btn active px-3 py-1 text-sm font-medium rounded-md transition-colors" data-filter="all">
                                    全て
                                </button>
                                <button id="filter-image" class="filter-btn px-3 py-1 text-sm font-medium rounded-md transition-colors" data-filter="image">
                                    画像のみ
                                </button>
                                <button id="filter-video" class="filter-btn px-3 py-1 text-sm font-medium rounded-md transition-colors" data-filter="video">
                                    動画のみ
                                </button>
                            </div>
                        </div>
                        <div class="text-sm text-gray-500">
                            <span id="file-count">${mediaFiles.length}</span> ファイル
                        </div>
                    </div>
                </div>
                
                <!-- ドラッグ&ドロップエリア -->
                <div id="drop-zone" class="px-6 py-8 border-b border-gray-200 bg-gradient-to-br from-blue-50 to-indigo-50 border-2 border-dashed border-blue-300 rounded-lg mx-6 mt-6 transition-all duration-300">
                    <div class="text-center">
                        <svg class="w-12 h-12 mx-auto mb-4 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                        </svg>
                        <h4 class="text-lg font-semibold text-gray-900 mb-2">ファイルをドラッグ&ドロップ</h4>
                        <p class="text-gray-600 mb-4">
                            画像ファイル（JPG, PNG, GIF）または動画ファイル（MP4, MOV, AVI）をここにドロップしてください
                        </p>
                        <div class="flex justify-center">
                            <label for="file-input" class="inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 cursor-pointer transition-colors">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                </svg>
                                ファイルを選択
                            </label>
                            <input type="file" id="file-input" class="hidden" multiple accept="image/*,video/*">
                        </div>
                    </div>
                    
                    <!-- アップロード進捗 -->
                    <div id="upload-progress" class="hidden mt-6">
                        <div class="bg-white rounded-lg p-4 shadow-sm">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm font-medium text-gray-700">アップロード中...</span>
                                <span id="upload-percentage" class="text-sm text-gray-500">0%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div id="upload-progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                            <div id="upload-status" class="mt-2 text-sm text-gray-600"></div>
                        </div>
                    </div>
                </div>
                
                <!-- ファイル一覧 -->
                <div class="p-6">
                    ${mediaFiles.length > 0 ? `
                    <div id="media-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-4">
                        ${renderMediaFiles(mediaFiles)}
                    </div>
                    ` : `
                    <div class="text-center py-16">
                        <div class="max-w-sm mx-auto">
                            <svg class="w-20 h-20 mx-auto mb-6 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                            </svg>
                            <h4 class="text-xl font-semibold text-gray-900 mb-3">メディアファイルがありません</h4>
                            <p class="text-gray-500 mb-8 leading-relaxed">
                                このプロジェクトにはまだメディアファイルがアップロードされていません。<br>
                                上のドロップエリアにファイルをドラッグ&ドロップしてください。
                            </p>
                        </div>
                    </div>
                    `}
                </div>
            </div>
        </div>
    `;
    
    mainContent.innerHTML = mediaLibraryHTML;
    
    // イベントリスナーを設定
    setupMediaLibraryEventListeners();
}

/**
 * メディアファイルの描画
 */
function renderMediaFiles(mediaFiles) {
    if (!mediaFiles || mediaFiles.length === 0) {
        return '';
    }
    
    return mediaFiles.map(file => {
        const isImage = file.file_type === 'image';
        const isVideo = file.file_type === 'video';
        
        return `
            <div class="media-item group relative bg-white border border-gray-200 rounded-lg overflow-hidden hover:shadow-md transition-all duration-200 cursor-pointer" 
                 data-file-id="${file.file_id}" 
                 data-file-type="${file.file_type}"
                 title="${Utils.escapeHtml(file.file_id)} (${file.size_formatted})">
                
                <!-- ファイルプレビュー -->
                <div class="aspect-square bg-gray-100 flex items-center justify-center relative overflow-hidden">
                    ${isImage ? `
                        <img src="${file.url}" 
                             class="w-full h-full object-cover" 
                             alt="${Utils.escapeHtml(file.file_id)}"
                             onerror="this.parentElement.innerHTML='<svg class=\\"w-8 h-8 text-gray-400\\" fill=\\"none\\" stroke=\\"currentColor\\" viewBox=\\"0 0 24 24\\"><path stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\\"></path></svg>'">
                    ` : isVideo ? `
                        <div class="relative w-full h-full bg-gray-800 flex items-center justify-center">
                            <svg class="w-12 h-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.586a1 1 0 01.707.293l2.414 2.414a1 1 0 00.707.293H15M9 10V9a2 2 0 012-2h2a2 2 0 012 2v1M9 10v5a2 2 0 002 2h2a2 2 0 002-2v-5"></path>
                            </svg>
                            <div class="absolute inset-0 bg-black bg-opacity-30 flex items-center justify-center">
                                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M8 5v14l11-7z"/>
                                </svg>
                            </div>
                        </div>
                    ` : `
                        <svg class="w-8 h-8 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                    `}
                    
                    <!-- 選択状態のオーバーレイ -->
                    <div class="selected-overlay absolute inset-0 bg-blue-600 bg-opacity-75 flex items-center justify-center opacity-0 transition-opacity duration-200">
                        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                    </div>
                </div>
                
                <!-- ファイル情報 -->
                <div class="p-2">
                    <div class="text-xs text-gray-600 truncate" title="${Utils.escapeHtml(file.file_id)}">
                        ${Utils.escapeHtml(file.file_id.length > 15 ? file.file_id.substring(0, 15) + '...' : file.file_id)}
                    </div>
                    <div class="text-xs text-gray-400 mt-1">
                        ${file.size_formatted}
                    </div>
                </div>
                
                <!-- 削除ボタン -->
                <button class="delete-file-btn absolute top-1 right-1 p-1 bg-red-600 text-white rounded-full opacity-0 group-hover:opacity-100 hover:bg-red-700 transition-all duration-200" 
                        data-file-id="${file.file_id}" 
                        title="ファイルを削除">
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
                
                <!-- ファイルタイプアイコン -->
                <div class="absolute top-1 left-1 px-1 py-0.5 bg-black bg-opacity-60 text-white text-xs rounded">
                    ${isImage ? 'IMG' : isVideo ? 'VID' : 'FILE'}
                </div>
            </div>
        `;
    }).join('');
}

/**
 * メディアライブラリのイベントリスナー設定
 */
function setupMediaLibraryEventListeners() {
    // シーン一覧に戻るボタン
    const backToScenesBtn = document.getElementById('back-to-scenes-btn');
    if (backToScenesBtn) {
        backToScenesBtn.addEventListener('click', () => {
            loadSceneListView(AppState.currentProject.id);
        });
    }
    
    // フィルタボタン
    const filterButtons = document.querySelectorAll('.filter-btn');
    filterButtons.forEach(btn => {
        btn.addEventListener('click', function() {
            const filter = this.dataset.filter;
            applyMediaFilter(filter);
            
            // アクティブ状態を更新
            filterButtons.forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });
    });
    
    // ドラッグ&ドロップ
    setupDragAndDrop();
    
    // ファイル選択
    const fileInput = document.getElementById('file-input');
    if (fileInput) {
        fileInput.addEventListener('change', handleFileSelection);
    }
    
    // メディアアイテムのクリック選択
    setupMediaItemSelection();
    
    // ファイル削除
    setupFileDeleteHandlers();
}

/**
 * メディアフィルタの適用
 */
function applyMediaFilter(filter) {
    const mediaItems = document.querySelectorAll('.media-item');
    let visibleCount = 0;
    
    mediaItems.forEach(item => {
        const fileType = item.dataset.fileType;
        const shouldShow = filter === 'all' || fileType === filter;
        
        if (shouldShow) {
            item.style.display = 'block';
            visibleCount++;
        } else {
            item.style.display = 'none';
        }
    });
    
    // ファイル数を更新
    const fileCountElement = document.getElementById('file-count');
    if (fileCountElement) {
        fileCountElement.textContent = visibleCount;
    }
}

/**
 * ドラッグ&ドロップの設定
 */
function setupDragAndDrop() {
    const dropZone = document.getElementById('drop-zone');
    if (!dropZone) return;
    
    // ドラッグオーバー時の視覚的フィードバック
    dropZone.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.classList.add('drag-over');
    });
    
    dropZone.addEventListener('dragleave', function(e) {
        e.preventDefault();
        if (!this.contains(e.relatedTarget)) {
            this.classList.remove('drag-over');
        }
    });
    
    dropZone.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
        
        const files = Array.from(e.dataTransfer.files);
        if (files.length > 0) {
            handleFileUpload(files);
        }
    });
}

/**
 * ファイル選択の処理
 */
function handleFileSelection(e) {
    const files = Array.from(e.target.files);
    if (files.length > 0) {
        handleFileUpload(files);
    }
    
    // ファイル入力をリセット
    e.target.value = '';
}

/**
 * メディアアイテムの選択設定
 */
function setupMediaItemSelection() {
    const mediaItems = document.querySelectorAll('.media-item');
    
    mediaItems.forEach(item => {
        item.addEventListener('click', function(e) {
            // 削除ボタンがクリックされた場合は選択処理をスキップ
            if (e.target.closest('.delete-file-btn')) {
                return;
            }
            
            // 選択状態を切り替え
            this.classList.toggle('selected');
            
            // 選択されたファイル数を更新
            updateSelectedFileCount();
        });
    });
}

/**
 * ファイル削除ハンドラーの設定
 */
function setupFileDeleteHandlers() {
    const deleteButtons = document.querySelectorAll('.delete-file-btn');
    
    deleteButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation(); // 親要素のクリックイベントを防ぐ
            
            const fileId = this.dataset.fileId;
            showDeleteFileConfirm(fileId);
        });
    });
}

/**
 * 選択されたファイル数の更新
 */
function updateSelectedFileCount() {
    const selectedItems = document.querySelectorAll('.media-item.selected');
    // 後で選択されたファイルの操作機能を追加する際に使用
    console.log(`${selectedItems.length} files selected`);
}

/**
 * ファイル削除確認ダイアログ
 */
function showDeleteFileConfirm(fileId) {
    const confirmed = confirm(`ファイル「${fileId}」を削除しますか？\n\nこのファイルを使用しているシーンからも自動的に関連付けが解除されます。`);
    
    if (confirmed) {
        deleteMediaFile(fileId);
    }
}

/**
 * メディアファイルの削除
 */
async function deleteMediaFile(fileId) {
    try {
        Loading.show('ファイルを削除中...');
        
        const response = await API.delete('api/media.php', {
            project_id: AppState.currentProject.id,
            file_id: fileId
        });
        
        if (response.success) {
            // ファイルアイテムをDOMから削除
            const fileItem = document.querySelector(`[data-file-id="${fileId}"]`);
            if (fileItem) {
                fileItem.remove();
            }
            
            // ファイル数を更新
            const remainingItems = document.querySelectorAll('.media-item');
            const fileCountElement = document.getElementById('file-count');
            if (fileCountElement) {
                fileCountElement.textContent = remainingItems.length;
            }
            
            // 空の状態を表示（必要に応じて）
            if (remainingItems.length === 0) {
                loadMediaLibraryView();
            }
            
            Notification.success('ファイルを削除しました');
        } else {
            throw new Error(response.error?.message || 'ファイルの削除に失敗しました');
        }
    } catch (error) {
        console.error('ファイル削除エラー:', error);
        Notification.error('ファイルの削除に失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * ファイルアップロードの処理
 */
async function handleFileUpload(files) {
    if (!AppState.currentProject) {
        Notification.error('プロジェクトが選択されていません');
        return;
    }
    
    try {
        // アップロード進捗を表示
        showUploadProgress();
        
        const formData = new FormData();
        formData.append('project_id', AppState.currentProject.id);
        
        // 複数ファイルを追加
        files.forEach(file => {
            formData.append('files[]', file);
        });
        
        // アップロード実行
        const response = await uploadWithProgress(formData);
        
        if (response.success) {
            // 成功メッセージ
            const message = response.data.success_count > 0 
                ? `${response.data.success_count}個のファイルをアップロードしました`
                : 'アップロードが完了しました';
            
            Notification.success(message);
            
            // エラーがあった場合は警告も表示
            if (response.data.error_count > 0) {
                Notification.warning(`${response.data.error_count}個のファイルでエラーが発生しました`);
            }
            
            // メディアライブラリを再読み込み
            setTimeout(() => {
                loadMediaLibraryView();
            }, 1000);
            
        } else {
            throw new Error(response.error?.message || 'アップロードに失敗しました');
        }
        
    } catch (error) {
        console.error('ファイルアップロードエラー:', error);
        Notification.error('ファイルのアップロードに失敗しました');
    } finally {
        hideUploadProgress();
    }
}

/**
 * アップロード進捗の表示
 */
function showUploadProgress() {
    const progressContainer = document.getElementById('upload-progress');
    if (progressContainer) {
        progressContainer.classList.remove('hidden');
    }
}

/**
 * アップロード進捗の非表示
 */
function hideUploadProgress() {
    const progressContainer = document.getElementById('upload-progress');
    if (progressContainer) {
        progressContainer.classList.add('hidden');
    }
    
    // 進捗をリセット
    const progressBar = document.getElementById('upload-progress-bar');
    const percentage = document.getElementById('upload-percentage');
    
    if (progressBar) progressBar.style.width = '0%';
    if (percentage) percentage.textContent = '0%';
}

/**
 * 進捗付きアップロード
 */
function uploadWithProgress(formData) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        
        // 進捗イベント
        xhr.upload.addEventListener('progress', function(e) {
            if (e.lengthComputable) {
                const percentComplete = Math.round((e.loaded / e.total) * 100);
                updateUploadProgress(percentComplete);
            }
        });
        
        // 完了イベント
        xhr.addEventListener('load', function() {
            try {
                const response = JSON.parse(xhr.responseText);
                resolve(response);
            } catch (error) {
                reject(new Error('レスポンスの解析に失敗しました'));
            }
        });
        
        // エラーイベント
        xhr.addEventListener('error', function() {
            reject(new Error('ネットワークエラーが発生しました'));
        });
        
        // リクエスト送信
        xhr.open('POST', 'api/media.php');
        xhr.send(formData);
    });
}

/**
 * アップロード進捗の更新
 */
function updateUploadProgress(percentage) {
    const progressBar = document.getElementById('upload-progress-bar');
    const percentageElement = document.getElementById('upload-percentage');
    const statusElement = document.getElementById('upload-status');
    
    if (progressBar) {
        progressBar.style.width = percentage + '%';
    }
    
    if (percentageElement) {
        percentageElement.textContent = percentage + '%';
    }
    
    if (statusElement) {
        if (percentage < 100) {
            statusElement.textContent = 'ファイルをアップロード中...';
        } else {
            statusElement.textContent = 'アップロード完了、処理中...';
        }
    }
}
/**

 * シーン一覧のイベントリスナーを設定
 */
function setupSceneListEventListeners() {
    // メディアライブラリボタン
    const mediaLibraryBtn = document.getElementById('media-library-btn');
    if (mediaLibraryBtn) {
        mediaLibraryBtn.addEventListener('click', showMediaLibrary);
    }
    
    // シーンファイルアップロードボタン
    const uploadScenesBtn = document.getElementById('upload-scenes-btn');
    if (uploadScenesBtn) {
        uploadScenesBtn.addEventListener('click', showSceneUploadModal);
    }
    
    // シーン追加ボタン
    const addSceneBtn = document.getElementById('add-scene-btn');
    if (addSceneBtn) {
        addSceneBtn.addEventListener('click', addNewScene);
    }
    
    // シーンフィールドの編集イベント
    setupSceneFieldEvents();
    
    // ドラッグ&ドロップイベント
    setupDragAndDropEvents();
    
    // シーン削除ボタン
    setupSceneDeleteEvents();
}

/**
 * シーンフィールドの編集イベントを設定
 */
function setupSceneFieldEvents() {
    const sceneFields = document.querySelectorAll('.scene-field');
    
    sceneFields.forEach(field => {
        // フォーカス時の処理
        field.addEventListener('focus', function() {
            this.classList.add('editing');
            this.dataset.originalValue = this.value;
        });
        
        // フォーカス離脱時の自動保存
        field.addEventListener('blur', function() {
            this.classList.remove('editing');
            
            if (this.value !== this.dataset.originalValue) {
                saveSceneField(this);
            }
        });
        
        // 時間フィールドのバリデーション
        if (field.dataset.field === 'start_time') {
            field.addEventListener('input', function() {
                validateTimeFormat(this);
            });
        }
    });
}

/**
 * ドラッグ&ドロップイベントを設定
 */
function setupDragAndDropEvents() {
    const sceneRows = document.querySelectorAll('.scene-row');
    
    sceneRows.forEach(row => {
        // ドラッグ開始
        row.addEventListener('dragstart', function(e) {
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.outerHTML);
            e.dataTransfer.setData('text/plain', this.dataset.sceneId);
        });
        
        // ドラッグ終了
        row.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            
            // すべての行からドロップ関連のクラスを削除
            document.querySelectorAll('.scene-row').forEach(r => {
                r.classList.remove('drag-over', 'drop-above', 'drop-below');
            });
        });
        
        // ドラッグオーバー
        row.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const draggingElement = document.querySelector('.scene-row.dragging');
            if (draggingElement && draggingElement !== this) {
                // ドロップ位置を決定
                const rect = this.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                
                // すべての行からドロップクラスを削除
                document.querySelectorAll('.scene-row').forEach(r => {
                    r.classList.remove('drop-above', 'drop-below');
                });
                
                if (e.clientY < midpoint) {
                    this.classList.add('drop-above');
                } else {
                    this.classList.add('drop-below');
                }
            }
        });
        
        // ドラッグリーブ
        row.addEventListener('dragleave', function(e) {
            // 要素の境界を完全に離れた場合のみクラスを削除
            const rect = this.getBoundingClientRect();
            if (e.clientX < rect.left || e.clientX > rect.right || 
                e.clientY < rect.top || e.clientY > rect.bottom) {
                this.classList.remove('drag-over', 'drop-above', 'drop-below');
            }
        });
        
        // ドロップ
        row.addEventListener('drop', function(e) {
            e.preventDefault();
            
            const draggedSceneId = e.dataTransfer.getData('text/plain');
            const draggedElement = document.querySelector(`[data-scene-id="${draggedSceneId}"]`);
            
            if (draggedElement && draggedElement !== this) {
                // ドロップ位置を決定
                const rect = this.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                const dropAbove = e.clientY < midpoint;
                
                // 新しい順序を計算
                reorderScenes(draggedSceneId, this.dataset.sceneId, dropAbove);
            }
            
            // クリーンアップ
            document.querySelectorAll('.scene-row').forEach(r => {
                r.classList.remove('dragging', 'drag-over', 'drop-above', 'drop-below');
            });
        });
    });
}

/**
 * シーン削除イベントを設定
 */
function setupSceneDeleteEvents() {
    const deleteButtons = document.querySelectorAll('.delete-scene-btn');
    
    deleteButtons.forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const sceneId = this.dataset.sceneId;
            showDeleteSceneConfirm(sceneId);
        });
    });
}

/**
 * シーンの並び替えを実行
 */
async function reorderScenes(draggedSceneId, targetSceneId, dropAbove) {
    try {
        // 現在のシーン順序を取得
        const sceneRows = Array.from(document.querySelectorAll('.scene-row'));
        const sceneIds = sceneRows.map(row => row.dataset.sceneId);
        
        // ドラッグされたシーンのインデックスを取得
        const draggedIndex = sceneIds.indexOf(draggedSceneId);
        const targetIndex = sceneIds.indexOf(targetSceneId);
        
        if (draggedIndex === -1 || targetIndex === -1) {
            throw new Error('Invalid scene IDs');
        }
        
        // 新しい順序を計算
        const newSceneIds = [...sceneIds];
        
        // ドラッグされたアイテムを削除
        newSceneIds.splice(draggedIndex, 1);
        
        // 新しい位置に挿入
        let insertIndex = targetIndex;
        if (draggedIndex < targetIndex) {
            insertIndex = targetIndex - 1;
        }
        
        if (!dropAbove) {
            insertIndex += 1;
        }
        
        newSceneIds.splice(insertIndex, 0, draggedSceneId);
        
        // APIに送信
        Loading.show('シーンを並び替え中...');
        
        const response = await API.post('api/scenes.php', {
            action: 'reorder',
            project_id: AppState.currentProject.id,
            scene_ids: newSceneIds
        });
        
        if (response.success) {
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            Notification.success('シーンの順序を更新しました');
        } else {
            throw new Error(response.error?.message || 'シーンの並び替えに失敗しました');
        }
        
    } catch (error) {
        console.error('シーン並び替えエラー:', error);
        Notification.error('シーンの並び替えに失敗しました');
        
        // エラー時はシーン一覧を再読み込みして元の状態に戻す
        await loadSceneListView(AppState.currentProject.id);
    } finally {
        Loading.hide();
    }
}

/**
 * シーンフィールドを保存
 */
async function saveSceneField(fieldElement) {
    const sceneId = fieldElement.dataset.sceneId;
    const fieldName = fieldElement.dataset.field;
    const value = fieldElement.value;
    
    // バリデーション
    if (fieldName === 'start_time' && !validateTimeFormat(fieldElement)) {
        return;
    }
    
    try {
        fieldElement.classList.add('saving');
        
        const updateData = {
            project_id: AppState.currentProject.id,
            [fieldName]: value
        };
        
        const response = await API.put(`api/scenes.php?id=${sceneId}`, updateData);
        
        if (response.success) {
            fieldElement.classList.remove('saving');
            fieldElement.classList.add('saved');
            
            // 保存完了の表示を一定時間後に削除
            setTimeout(() => {
                fieldElement.classList.remove('saved');
            }, 2000);
        } else {
            throw new Error(response.error?.message || 'シーンの更新に失敗しました');
        }
        
    } catch (error) {
        console.error('シーンフィールド保存エラー:', error);
        fieldElement.classList.remove('saving');
        fieldElement.classList.add('save-error');
        
        // エラー表示を一定時間後に削除
        setTimeout(() => {
            fieldElement.classList.remove('save-error');
        }, 3000);
        
        Notification.error('シーンの保存に失敗しました');
    }
}

/**
 * 時間フォーマットのバリデーション
 */
function validateTimeFormat(timeField) {
    const value = timeField.value;
    const timePattern = /^(\d{1,2}):([0-5]\d)$/;
    
    if (value && !timePattern.test(value)) {
        timeField.classList.add('invalid');
        
        // バリデーションエラーメッセージを表示
        showValidationError(timeField, '時間は M:SS または MM:SS の形式で入力してください');
        
        setTimeout(() => {
            timeField.classList.remove('invalid');
        }, 3000);
        
        return false;
    } else {
        timeField.classList.remove('invalid');
        hideValidationError(timeField);
        return true;
    }
}

/**
 * バリデーションエラーメッセージを表示
 */
function showValidationError(field, message) {
    // 既存のエラーメッセージを削除
    hideValidationError(field);
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error absolute z-20 mt-1 p-2 text-xs text-red-600 bg-red-50 border border-red-200 rounded shadow-lg';
    errorDiv.textContent = message;
    errorDiv.dataset.fieldId = field.dataset.sceneId + '_' + field.dataset.field;
    
    // フィールドの親要素に相対位置を設定
    const parent = field.closest('td');
    if (parent) {
        parent.style.position = 'relative';
        parent.appendChild(errorDiv);
    }
}

/**
 * バリデーションエラーメッセージを非表示
 */
function hideValidationError(field) {
    const fieldId = field.dataset.sceneId + '_' + field.dataset.field;
    const existingError = document.querySelector(`[data-field-id="${fieldId}"]`);
    if (existingError) {
        existingError.remove();
    }
}

/**
 * 新しいシーンを追加
 */
async function addNewScene() {
    try {
        Loading.show('シーンを追加中...');
        
        const response = await API.post('api/scenes.php', {
            project_id: AppState.currentProject.id,
            start_time: '0:00',
            lyrics: '',
            description: '',
            image_prompt: '',
            video_prompt: ''
        });
        
        if (response.success) {
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            Notification.success('新しいシーンを追加しました');
        } else {
            throw new Error(response.error?.message || 'シーンの追加に失敗しました');
        }
        
    } catch (error) {
        console.error('シーン追加エラー:', error);
        Notification.error('シーンの追加に失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * シーン削除確認ダイアログを表示
 */
function showDeleteSceneConfirm(sceneId) {
    const modal = document.getElementById('modal-container');
    
    const modalHTML = `
        <div class="modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
            <div class="modal-content bg-white rounded-lg shadow-xl max-w-md w-full">
                <div class="p-6">
                    <div class="flex items-center mb-4">
                        <div class="flex-shrink-0 w-10 h-10 bg-red-100 rounded-full flex items-center justify-center">
                            <svg class="w-6 h-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                            </svg>
                        </div>
                        <div class="ml-4">
                            <h3 class="text-lg font-medium text-gray-900">シーンを削除</h3>
                            <p class="text-sm text-gray-500 mt-1">この操作は取り消せません。</p>
                        </div>
                    </div>
                    
                    <p class="text-gray-700 mb-6">
                        このシーンを削除してもよろしいですか？関連付けられたメディアファイルは削除されませんが、シーンとの関連付けは解除されます。
                    </p>
                    
                    <div class="flex justify-end space-x-3">
                        <button id="cancel-delete" class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 transition-colors">
                            キャンセル
                        </button>
                        <button id="confirm-delete" class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors">
                            削除する
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    modal.innerHTML = modalHTML;
    modal.classList.remove('hidden');
    
    // イベントリスナー
    document.getElementById('cancel-delete').addEventListener('click', () => {
        modal.classList.add('hidden');
    });
    
    document.getElementById('confirm-delete').addEventListener('click', () => {
        deleteScene(sceneId);
        modal.classList.add('hidden');
    });
    
    // 背景クリックで閉じる
    modal.querySelector('.modal-backdrop').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
            modal.classList.add('hidden');
        }
    });
}

/**
 * シーンを削除
 */
async function deleteScene(sceneId) {
    try {
        Loading.show('シーンを削除中...');
        
        const response = await API.delete('api/scenes.php', {
            id: sceneId,
            project_id: AppState.currentProject.id
        });
        
        if (response.success) {
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            Notification.success('シーンを削除しました');
        } else {
            throw new Error(response.error?.message || 'シーンの削除に失敗しました');
        }
        
    } catch (error) {
        console.error('シーン削除エラー:', error);
        Notification.error('シーンの削除に失敗しました');
    } finally {
        Loading.hide();
    }
}

// 未実装の関数のスタブ
function showMediaLibrary() {
    Notification.info('メディアライブラリ機能は実装中です');
}

async function loadSceneListView(projectId) {
    // シーン一覧の再読み込み機能（実装済みの場合は実際の処理を呼び出し）
    Notification.info('シーン一覧を更新しました');
}

function showSceneUploadModal() {
    Notification.info('シーンファイルアップロード機能は実装中です');
}

/**
 * シーン詳細編集画面を開く
 */
async function openSceneDetail(sceneId) {
    try {
        Loading.show('シーン詳細を読み込み中...');
        
        // シーン詳細情報を取得
        const sceneResponse = await API.get('api/scenes.php', { 
            project_id: AppState.currentProject.id,
            scene_id: sceneId 
        });
        
        if (!sceneResponse.success) {
            throw new Error(sceneResponse.error?.message || 'シーン詳細の読み込みに失敗しました');
        }
        
        const scene = sceneResponse.data.find(s => s.id === sceneId);
        if (!scene) {
            throw new Error('シーンが見つかりません');
        }
        
        // メディアライブラリの情報を取得
        const mediaResponse = await API.get('api/media.php', { 
            project_id: AppState.currentProject.id 
        });
        
        const mediaFiles = mediaResponse.success ? mediaResponse.data : [];
        
        // シーン詳細編集モーダルを表示
        showSceneDetailModal(scene, mediaFiles);
        
    } catch (error) {
        console.error('シーン詳細読み込みエラー:', error);
        Notification.error('シーン詳細の読み込みに失敗しました');
    } finally {
        Loading.hide();
    }
}

/**
 * シーン詳細編集モーダルを表示
 */
function showSceneDetailModal(scene, mediaFiles) {
    const imageFiles = mediaFiles.filter(file => file.type === 'image');
    const videoFiles = mediaFiles.filter(file => file.type === 'video');
    
    const modal = createModal(`シーン詳細編集 - ${scene.start_time || '新規シーン'}`, `
        <div class="max-w-4xl mx-auto">
            <form id="scene-detail-form" class="space-y-6">
                <!-- 基本情報 -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">開始時間</label>
                        <input type="text" 
                               id="scene-start-time" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                               value="${Utils.escapeHtml(scene.start_time || '')}"
                               placeholder="0:00"
                               pattern="[0-9]+:[0-5][0-9]">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">シーン番号</label>
                        <input type="text" 
                               class="w-full px-3 py-2 bg-gray-100 border border-gray-300 rounded-md text-gray-500"
                               value="シーン ${scene.order || 'N/A'}"
                               readonly>
                    </div>
                </div>
                
                <!-- 歌詞とシーン説明 -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">歌詞</label>
                        <textarea id="scene-lyrics" 
                                  rows="4"
                                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                  placeholder="このシーンの歌詞を入力...">${Utils.escapeHtml(scene.lyrics || '')}</textarea>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">シーン説明</label>
                        <textarea id="scene-description" 
                                  rows="4"
                                  class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                  placeholder="映像の内容やコンセプトを説明...">${Utils.escapeHtml(scene.description || '')}</textarea>
                    </div>
                </div>
                
                <!-- 画像セクション -->
                <div class="border border-gray-200 rounded-lg p-6 bg-gray-50">
                    <h3 class="text-lg font-medium text-gray-900 mb-4 flex items-center">
                        <svg class="w-5 h-5 mr-2 text-primary-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                        </svg>
                        画像設定
                    </h3>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">画像生成プロンプト</label>
                            <textarea id="scene-image-prompt" 
                                      rows="4"
                                      class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                      placeholder="AI画像生成用のプロンプトを入力...">${Utils.escapeHtml(scene.image_prompt || '')}</textarea>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">関連付け画像ファイル</label>
                            <div class="space-y-3">
                                ${scene.image_file_id ? `
                                <div class="current-image p-3 bg-white border border-gray-300 rounded-md">
                                    <div class="flex items-center justify-between">
                                        <div class="flex items-center">
                                            <img src="data/projects/${AppState.currentProject.id}/media/images/${scene.image_file_id}" 
                                                 class="w-12 h-12 object-cover rounded mr-3"
                                                 alt="現在の画像">
                                            <div>
                                                <p class="text-sm font-medium text-gray-900">${scene.image_file_id}</p>
                                                <p class="text-xs text-gray-500">現在選択中</p>
                                            </div>
                                        </div>
                                        <button type="button" 
                                                class="text-red-600 hover:text-red-800 text-sm"
                                                onclick="clearImageSelection()">
                                            削除
                                        </button>
                                    </div>
                                </div>
                                ` : ''}
                                
                                <div class="image-selection">
                                    <select id="scene-image-file" 
                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500">
                                        <option value="">画像ファイルを選択...</option>
                                        ${imageFiles.map(file => `
                                            <option value="${file.filename}" ${scene.image_file_id === file.filename ? 'selected' : ''}>
                                                ${file.filename} (${Utils.formatFileSize(file.size)})
                                            </option>
                                        `).join('')}
                                    </select>
                                    
                                    ${imageFiles.length === 0 ? `
                                    <p class="text-sm text-gray-500 mt-2">
                                        画像ファイルがありません。
                                        <button type="button" class="text-primary-600 hover:text-primary-800" onclick="openMediaLibrary()">
                                            メディアライブラリ
                                        </button>
                                        からファイルをアップロードしてください。
                                    </p>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 動画セクション -->
                <div class="border border-gray-200 rounded-lg p-6 bg-gray-50">
                    <h3 class="text-lg font-medium text-gray-900 mb-4 flex items-center">
                        <svg class="w-5 h-5 mr-2 text-primary-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                        動画設定
                    </h3>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">動画生成プロンプト</label>
                            <textarea id="scene-video-prompt" 
                                      rows="4"
                                      class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500"
                                      placeholder="AI動画生成用のプロンプトを入力...">${Utils.escapeHtml(scene.video_prompt || '')}</textarea>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">関連付け動画ファイル</label>
                            <div class="space-y-3">
                                ${scene.video_file_id ? `
                                <div class="current-video p-3 bg-white border border-gray-300 rounded-md">
                                    <div class="flex items-center justify-between">
                                        <div class="flex items-center">
                                            <div class="w-12 h-12 bg-gray-200 rounded flex items-center justify-center mr-3">
                                                <svg class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                                </svg>
                                            </div>
                                            <div>
                                                <p class="text-sm font-medium text-gray-900">${scene.video_file_id}</p>
                                                <p class="text-xs text-gray-500">現在選択中</p>
                                            </div>
                                        </div>
                                        <button type="button" 
                                                class="text-red-600 hover:text-red-800 text-sm"
                                                onclick="clearVideoSelection()">
                                            削除
                                        </button>
                                    </div>
                                </div>
                                ` : ''}
                                
                                <div class="video-selection">
                                    <select id="scene-video-file" 
                                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-primary-500">
                                        <option value="">動画ファイルを選択...</option>
                                        ${videoFiles.map(file => `
                                            <option value="${file.filename}" ${scene.video_file_id === file.filename ? 'selected' : ''}>
                                                ${file.filename} (${Utils.formatFileSize(file.size)})
                                            </option>
                                        `).join('')}
                                    </select>
                                    
                                    ${videoFiles.length === 0 ? `
                                    <p class="text-sm text-gray-500 mt-2">
                                        動画ファイルがありません。
                                        <button type="button" class="text-primary-600 hover:text-primary-800" onclick="openMediaLibrary()">
                                            メディアライブラリ
                                        </button>
                                        からファイルをアップロードしてください。
                                    </p>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ボタン -->
                <div class="flex justify-end space-x-3 pt-6 border-t border-gray-200">
                    <button type="button" 
                            id="cancel-scene-detail" 
                            class="px-6 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500">
                        キャンセル
                    </button>
                    <button type="submit" 
                            id="save-scene-detail" 
                            class="px-6 py-2 text-sm font-medium text-white bg-primary-600 rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500">
                        保存
                    </button>
                </div>
            </form>
        </div>
    `, 'max-w-6xl');
    
    // イベントリスナーを設定
    setupSceneDetailEventListeners(scene);
}

/**
 * シーン詳細編集のイベントリスナーを設定
 */
function setupSceneDetailEventListeners(scene) {
    const form = document.getElementById('scene-detail-form');
    const cancelBtn = document.getElementById('cancel-scene-detail');
    
    // フォーム送信
    form.addEventListener('submit', function(e) {
        e.preventDefault();
        saveSceneDetail(scene.id);
    });
    
    // キャンセルボタン
    cancelBtn.addEventListener('click', () => {
        closeModal();
    });
    
    // 時間フィールドのバリデーション
    const startTimeField = document.getElementById('scene-start-time');
    startTimeField.addEventListener('input', function() {
        const value = this.value;
        const timePattern = /^[0-9]+:[0-5][0-9]$/;
        
        if (value && !timePattern.test(value)) {
            this.classList.add('border-red-500');
            this.classList.remove('border-gray-300');
        } else {
            this.classList.remove('border-red-500');
            this.classList.add('border-gray-300');
        }
    });
}

/**
 * 画像選択をクリア
 */
function clearImageSelection() {
    const imageSelect = document.getElementById('scene-image-file');
    if (imageSelect) {
        imageSelect.value = '';
    }
    
    const currentImage = document.querySelector('.current-image');
    if (currentImage) {
        currentImage.style.display = 'none';
    }
}

/**
 * 動画選択をクリア
 */
function clearVideoSelection() {
    const videoSelect = document.getElementById('scene-video-file');
    if (videoSelect) {
        videoSelect.value = '';
    }
    
    const currentVideo = document.querySelector('.current-video');
    if (currentVideo) {
        currentVideo.style.display = 'none';
    }
}

/**
 * メディアライブラリを開く
 */
function openMediaLibrary() {
    closeModal();
    showMediaLibrary();
}

/**
 * シーン詳細を保存
 */
async function saveSceneDetail(sceneId) {
    try {
        Loading.show('シーン詳細を保存中...');
        
        // フォームデータを収集
        const formData = {
            start_time: document.getElementById('scene-start-time').value,
            lyrics: document.getElementById('scene-lyrics').value,
            description: document.getElementById('scene-description').value,
            image_prompt: document.getElementById('scene-image-prompt').value,
            video_prompt: document.getElementById('scene-video-prompt').value,
            image_file_id: document.getElementById('scene-image-file').value || null,
            video_file_id: document.getElementById('scene-video-file').value || null
        };
        
        // バリデーション
        if (formData.start_time) {
            const timePattern = /^[0-9]+:[0-5][0-9]$/;
            if (!timePattern.test(formData.start_time)) {
                throw new Error('時間フォーマットが正しくありません（M:SS または MM:SS）');
            }
        }
        
        // API呼び出し
        const response = await API.put(`api/scenes.php?id=${sceneId}`, formData);
        
        if (response.success) {
            closeModal();
            
            // シーン一覧を再読み込み
            await loadSceneListView(AppState.currentProject.id);
            
            Notification.success('シーン詳細を保存しました');
        } else {
            throw new Error(response.error?.message || 'シーン詳細の保存に失敗しました');
        }
        
    } catch (error) {
        console.error('シーン詳細保存エラー:', error);
        Notification.error(error.message || 'シーン詳細の保存に失敗しました');
    } finally {
        Loading.hide();
    }
}

function showCreateProjectModal() {
    Notification.info('プロジェクト作成機能は実装中です');
}

function showEditProjectModal(projectId) {
    Notification.info('プロジェクト編集機能は実装中です');
}

function showDeleteProjectConfirm(projectId) {
    Notification.info('プロジェクト削除機能は実装中です');
}